# Markdown
Markdown 是一种可以使用普通文本编辑器编写的标记语言 

## 作用
1. 写笔记
2. 写文档
3. 写博客

## 特点
1. 语法简洁
2. 样式和内容分离
3. 编辑方便

## 编辑使用的软件
* typora								<https://www.typora.io/>
* 有道云笔记                        <http://note.youdao.com/>
* markdownpad
* webstorm  HBuilder  vscode

## 语法
#### 兼容 HTML

```
<span style="color:red">兼容html哦</span>
```

#### 标题

```
## 标题
### 标题
#### 标题
```

#### 引用

```
> 我的舞蹈没人能跳第二遍,包括我自己
```

#### 无序列表

```
* 苹果
* 香蕉
* 梨子
- 菠萝
- 山楂
- 桔子
```

#### 有序列表

```
1. apple
2. 华硕
3. 宏基
```

#### 代码块儿

```
​```js
​```
```

#### 分割线

```
---
```

#### 加粗

```
**他不是猪才怪**
```

#### 小段代码 加亮

```js
`console.log('iloveyou')`
```

#### 图片

```
![image](http://cdn.xiaohigh.com/author.png)
```

#### 链接

```
[xiaohigh](http://i.xiaohigh.com/)
```

#### 表格

```
ID | 用户名
---|---
1 | 张三
2 | 李四
```
# ES5

### 严格模式

#### 介绍

ES5 除了正常运行模式（又称为混杂模式），还添加了第二种运行模式："[严格模式](<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode>)"（strict mode）。

严格模式顾名思义，就是使 Javascript 在更严格的语法条件下运行。

#### 作用
1.  消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为
2.  消除代码运行的一些不安全之处，保证代码运行的安全
3.  为未来新版本的 JavaScript 做好铺垫

#### 使用

* 在全局或函数的第一条语句定义为: `'use strict'`

* 如果浏览器不支持，只解析为一条简单的语句, 没有任何副作用

  ```js
  // 全局使用严格模式
  'use strict';
  girl = '迪丽热巴';
  
  // 函数中使用严格模式
  function main(){
  	'use strict';
  	boy = '吴亦凡';
  }
  main();
  ```

#### 语法和行为改变

* 必须用 var 声明变量，不允许使用未声明的变量
* 禁止自定义的函数中的 this 指向 window
* 创建 eval 作用域
* 对象不能有重名的属性（ES6 已经修复了这个 Bug，IE 还会出现）
* 函数不能有重复的形参
* 新增一些保留字, 如: implements interface private protected public

### Object 扩展方法

#### Object.create(prototype, [descriptors])

Object.create 方法可以以指定对象为原型创建新的对象，同时可以为新的对象设置属性, 并对属性进行描述

* value : 指定值
* writable : 标识当前属性值是否是可修改的, 默认为 false
* configurable：标识当前属性是否可以被删除 默认为 false
* enumerable：标识当前属性是否能用for in 枚举 默认为 false
* get:   当获取当前属性时的回调函数
* set:   当设置当前属性时

```js
//创建一个汽车的对象
var car = {
    name : '汽车',
    run: function(){
        console.log('我可以行驶！！');
    }
};

//以 car 为原型对象创建新对象
var aodi = Object.create(car, {
    brand: {
        value: '奥迪',
        writable: false,         //是否可修改
        configurable: false,     //是否可以删除
        enumerable: true         //是否可以使用 for...in 遍历
    },
    color: {
        value : '黑色',
        wriable: false,
        configurable: false,
        enumerable: true
    }
});
```

#### Object.defineProperties(object, descriptors)

直接在一个对象上定义新的属性或修改现有属性，并返回该对象。

* object     要操作的对象
* descriptors     属性描述
  * get  作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。
  * set  作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。

```js
// 定义对象
var star = {
    firstName: '刘',
    lastName : '德华'
};

// 为 star 定义额外的属性
Object.defineProperties(star, {
    fullName: {
        get: function(){
            return this.firstName + this.lastName;
        },
        set: function(name){
            var res = name.split('-');
            this.firstName = res[0];
            this.lastName = res[1];
        }
    }
});

// 修改 fullName 属性值
star.fullName = '张-学友';

// 打印属性
console.log(star.fullName);
```

### call、apply 和 bind

* call 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数

* apply 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数

* bind 同 call 相似，不过该方法会返回一个新的函数，而不会立即执行

```js
function main(){
    console.log(this);
}
/*1. 直接调用函数*/
main();										//  window
/*2. 创建一个对象*/
var company = {name: '尚硅谷', age: 10};
/*使用这个对象调用 main 方法*/
main.call(company);							// company
main.apply(company);						// company
/*bind 修改 this 的值，返回一个新的函数*/
var fn = main.bind(company);
fn();										// company
```

# Es6

## let关键词

* let关键字用来声明变量，使用let声明的变量有几个特点：

  * 不允许重复声明
  * 块儿级作用域
  * 不存在变量提升

  <h4 style='color:red'>应用场景：以后声明变量全用let</h4>

## const关键词

* const 关键字用来声明常量，const声明有以下特点

  * 不允许重复声明
  * 值不允许修改
  * 块儿级作用域

  <h4 style='color:red'>应用场景：以后声明变量全用let</h4>

## 变量的解构赋值

* ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。

  * ```js
    //数组的解构赋值
    const arr = ['张学友', '刘德华', '黎明', '郭富城'];
    let [zhang, liu, li, guo] = arr;
    
    //对象的解构赋值
    const lin = {
        name: '林志颖',
        tags: ['车手', '歌手', '小旋风', '演员']
    };
    let {name, tags} = lin;
    
    //复杂解构
    let wangfei = {
        name: '王菲',
        age: 18,
        songs: ['红豆', '流年', '暧昧', '传奇'],
        history: [
            {name: '窦唯'},
            {name: '李亚鹏'},
            {name: '谢霆锋'}
        ]
    };
    let {songs: [one, two, three], history: [first, second, third]} = wangfei;
    
    
    ```

  <h4 style='color:red'>注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式</h4>

## 模板字符串

* 模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：

  * 字符串中可以出现换行符

  * 可以使用 ${xxx} 形式输出变量

    ```js
    // 定义字符串
    let str = `<ul>
            <li>沈腾</li>
            <li>玛丽</li>
            <li>魏翔</li>
            <li>艾伦</li>
        </ul>`;
    
    // 变量拼接
    let star = '王宁';
    let result = `${star}在前几年离开了开心麻花`;
    
    ```

  <h4 style='color:red'>注意：当遇到字符串与变量拼接的情况使用模板字符串 </h4>

## 简化对象写法

* ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。

  ```js
  let name = '尚硅谷';
  let slogon = '永远追求行业更高标准';
  let improve = function () {
      console.log('可以提高你的技能');
  }
  //属性和方法简写
  let atguigu = {
      name,
      slogon,
      improve,
      change() {
          console.log('可以改变你')
      }
  };
  
  ```

  <h4 style='color:red'>注意：对象简写形式简化了代码，所以以后用简写就对了  </h4>

## 箭头函数

* ES6 允许使用「箭头」（=>）定义函数。

  ```js
  /**
   * 1. 通用写法
   */
  let fn = (arg1, arg2, arg3) => {
      return arg1 + arg2 + arg3;
  }
  
  ```

* 箭头函数的注意点:

  * 如果形参只有一个，则小括号可以省略
  * 函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果
  * 箭头函数this指向声明时所在作用域下 this 的值
  * 箭头函数不能作为构造函数实例化

  ```js
  /**
   * 2. 省略小括号的情况
   */
  let fn2 = num => {
      return num * 10;
  };
  
  /**
   * 3. 省略花括号的情况
   */
  let fn3 = score => score * 20;
  
  /**
   * 4. this指向声明时所在作用域中 this 的值
   */
  let fn4 = () => {
      console.log(this);
  }
  
  let school = {
      name: '尚硅谷',
      getName(){
          let fn5 = () => {
              console.log(this);
          }
          fn5();
      }
  };
  
  ```

  <h4 style='color:red'>注意：箭头函数不会更改this指向，所以非常适合设置与this无关的回调，比如数组回调、定时器回调，不适合事件回调与对象方法。 </h4>

## rest参数

* ES6引入rest参数，用于获取函数的实参，用来代替arguments

  ```js
  /**
   * 作用与 arguments 类似
   */
  function add(...args){
      console.log(args);
  }
  add(1,2,3,4,5);
  
  /**
   * rest 参数必须是最后一个形参
   */
  function minus(a,b,...args){
      console.log(a,b,args);
  }
  minus(100,1,2,3,4,5,19);
  
  ```

  <h4 style='color:red'>注意：rest参数非常适合不定个数参数函数的场景</h4>

## spread扩展运算符

* 扩展运算符（spread）也是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。

  ```js
  /**
   * 展开数组
   */ 
  let tfboys = ['德玛西亚之力','德玛西亚之翼','德玛西亚皇子'];
  function fn(){
      console.log(arguments);
  }
  fn(...tfboys)
  
  
  /**
   * 展开对象
   */
  let skillOne = {
      q: '致命打击',
  };
  let skillTwo = {
      w: '勇气'
  };
  let skillThree = {
      e: '审判'
  };
  let skillFour = {
      r: '德玛西亚正义'
  };
  
  let gailun = {...skillOne, ...skillTwo,...skillThree,...skillFour};
  
  ```

## Symbol

### synbol基本使用

* ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。

* Symbol特点

  * Symbol的值是唯一的，用来解决命名冲突的问题

  * Symbol值不能与其他数据进行运算

  * 1)    Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名

    ```js
    //创建 Symbol
    let s1 = Symbol();
    console.log(s1, typeof s1);
    
    //添加标识的 Symbol
    let s2 = Symbol('尚硅谷');
    let s2_2 = Symbol('尚硅谷');
    console.log(s2 === s2_2);
    
    //使用 Symbol for 定义
    let s3 = Symbol.for('尚硅谷');
    let s3_2 = Symbol.for('尚硅谷');
    console.log(s3 === s3_2);
    
    ```

### Symbol内置值

* 除了定义自己使用的 Symbol 值以外，ES6 还提供了11个内置的Symbol值，指向语言内部使用的方法。

  | Symbol.hasInstance        | 当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法 |
  | ------------------------- | ------------------------------------------------------------ |
  | Symbol.isConcatSpreadable | 对象的Symbol.isConcatSpreadable属性等于的是一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 |
  | Symbol. unscopables       | 该对象指定了使用with关键字时，哪些属性会被with环境排除。     |
  | Symbol.match              | 当执行str.match(myObject) 时，如果该属性存在，会调用它，返回该方法的返回值。 |
  | Symbol.replace            | 当该对象被str.replace(myObject)方法调用时，会返回该方法的返回值。 |
  | Symbol.search             | 当该对象被str. search (myObject)方法调用时，会返回该方法的返回值。 |
  | Symbol.split              | 当该对象被str. split (myObject)方法调用时，会返回该方法的返回值。 |
  | Symbol.iterator           | 对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器 |
  | Symbol.toPrimitive        | 该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 |
  | Symbol. toStringTag       | 在该对象上面调用toString方法时，返回该方法的返回值           |
  | Symbol.species            | 创建衍生对象时，会使用该属性                                 |

## 迭代器

* 迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。

  * ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费

  * 原生具备iterator接口的数据(可用for of遍历)

    * Array
    * Arguments
    * Set
    * Map
    * String
    * TypedArray
    * NodeList

  * 工作原理

    1. 创建一个指针对象，指向当前数据结构的起始位置
    2. 第一次调用对象的next方法，指针自动指向数据结构的第一个成员
    3. 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员
    4. 每调用next方法返回一个包含value和done属性的对象

    <h4 style='color:red'>注: 需要自定义遍历数据的时候，要想到迭代器。</h4>

## 生成器

* 生成器函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同

  ```js
  function * gen(){
      yield '一只没有耳朵';
      yield '一只没有尾巴';
      return '真奇怪';
  }
  let iterator = gen();
  console.log(iterator.next());
  console.log(iterator.next());
  console.log(iterator.next());
  
  ```

* 代码说明：

  *  \* 的位置没有限制
  * 生成器函数返回的结果是迭代器对象，调用迭代器对象的next方法可以得到yield语句后的值
  *  yield相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次next方法，执行一段代码
  * next方法可以传递实参，作为yield语句的返回值

## Promise

* Promise是ES6引入的异步编程的新解决方案。语法上Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。

## Set

* ES6 提供了新的数据结构 Set（集合）。它类似于数组，但成员的值都是唯一的，集合实现了iterator接口，所以可以使用『扩展运算符』和『for…of…』进行遍历，集合的属性和方法：

  * size    返回集合的元素个数

  * add    增加一个新元素，返回当前集合

  * delete  删除元素，返回boolean 值

  * has     检测集合中是否包含某个元素，返回boolean值

  * clear   清空集合，返回undefined

    ```js
    //创建一个空集合
    let s = new Set();
    //创建一个非空集合
    let s1 = new Set([1,2,3,1,2,3]);
    
    //集合属性与方法
    //返回集合的元素个数
    console.log(s1.size);
    //添加新元素
    console.log(s1.add(4));
    //删除元素
    console.log(s1.delete(1));
    //检测是否存在某个值
    console.log(s1.has(2));
    //清空集合
    console.log(s1.clear());
    
    ```

## Map

* ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map也实现了iterator接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。Map的属性和方法：

  * size    返回Map的元素个数
  * set     增加一个新元素，返回当前Map
  * get     返回键名对象的键值
  * has     检测Map中是否包含某个元素，返回boolean值
  * clear   清空集合，返回undefined

  ```js
  //创建一个空 map
  let m = new Map();
  //创建一个非空 map
  let m2 = new Map([
      ['name','尚硅谷'],
      ['slogon','不断提高行业标准']
  ]);
  
  //属性和方法
  //获取映射元素的个数
  console.log(m2.size);
  //添加映射值
  console.log(m2.set('age', 6));
  //获取映射值
  console.log(m2.get('age'));
  //检测是否有该映射
  console.log(m2.has('age'));
  //清除
  console.log(m2.clear());
  
  ```

## class类

* ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

  * class声明类
  * constructor定义构造函数初始化
  * extends继承父类
  * super调用父级构造方法
  * static定义静态方法和属性
  * 父类方法可以重写

  ```js
  //父类
  class Phone {
      //构造方法
      constructor(brand, color, price) {
          this.brand = brand;
          this.color = color;
          this.price = price;
      }
  
      //对象方法
      call() {
          console.log('我可以打电话!!!')
      }
  }
  
  //子类
  class SmartPhone extends Phone {
  
      constructor(brand, color, price, screen, pixel) {
          super(brand, color, price);
          this.screen = screen;
          this.pixel = pixel;
      }
  
      //子类方法
      photo(){
          console.log('我可以拍照!!');
      }
  
      playGame(){
          console.log('我可以玩游戏!!');
      }
  
      //方法重写
      call(){
          console.log('我可以进行视频通话!!');
      }
  
      //静态方法
      static run(){
          console.log('我可以运行程序')
      }
  
      static connect(){
          console.log('我可以建立连接')
      }
  }
  
  //实例化对象
  const Nokia = new Phone('诺基亚', '灰色', 230);
  const iPhone6s = new SmartPhone('苹果', '白色', 6088, '4.7inch','500w');
  
  //调用子类方法
  iPhone6s.playGame();
  //调用重写方法
  iPhone6s.call();
  //调用静态方法
  SmartPhone.run();
  
  ```

## 数值扩增

### 二进制和八进制

* ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。

### Number

#### Number.isFinite() 与Number.isNaN() 

* Number.isFinite() 用来检查一个数值是否为有限的
* Number.isNaN() 用来检查一个值是否为NaN

#### Number.parseInt() 与Number.parseFloat()

* ES6 将全局方法parseInt和parseFloat，移植到Number对象上面，使用不变。

#### Math.trunc

* 用于去除一个数的小数部分，返回整数部分。

#### Number.isInteger

* Number.isInteger() 用来判断一个数值是否为整数

## 对象的扩增

* ES6新增了一些Object对象的方法
  * Object.is 比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN）
  * Object.assign 对象的合并，将源对象的所有可枚举属性，复制到目标对象
  * __proto__、setPrototypeOf、 setPrototypeOf可以直接设置对象的原型

  


# Git 介绍

Git 是一款开源免费的分布式的版本控制系统。是 Linux 之父 Linus Torvalds （**林纳斯·托瓦兹**）为了方便管理 Linux 内核代码而开发的。

## 作用

版本控制系统在项目开发中作用重大，能记录文件的历史状态，主要的功能有以下几点

- 代码备份
- 版本回退
- 协作开发
- 权限控制

## 下载安装

下载地址 <https://git-scm.com/>

安装方式与 QQ 安装相同，一路下一步，中间可以设置软件的安装路径

## Linux 常用命令

Linux 是一套开源免费的操作系统。与系统的交互通常用命令来实现，常用的命令有：

- ==ls==         查看当前文件夹下的文件 （list 单词的缩写）   `ls -al` 查看隐藏文件并竖向排布
- ==cd==       进入某一个文件夹内 （change directory 缩写） ==cd ..== 回到上一级  ==Tab 键自动补全路径==
- clear   清屏（也可以使用 ==ctrl + l== 快捷键）
- mkdir  创建文件夹（make directory）
- touch  test.html   创建一个文件
- rm   test.html   删除文件 remove
- rm  dir   -r   删除文件夹 (-r 删除文件夹选项  -f 强制) force 
- mv   test.html  t.html   移动文件，重命名  move 缩写
- cat   test.html  查看文件内容
- ctrl + c 取消命令 (cancel)
- Tab 自动补齐路径
- 上下方向键，可以查看命令历史 (history 查看所有的历史命令)

Vim 是一款命令行下的文本编辑器，编辑方式跟图形化编辑器不同

* `vim test.html`  编辑文件（文件不存在则创建）
* i    进入编辑模式(i  insert)
* `ESC` + `:wq` 保存并退出
* `ESC` + `:q!` 不保存并退出

![img](assets/vim-vi-workmodel.png)

## Git 使用

### 起始配置

第一次使用 Git 的时候，会要求我们配置用户名和邮箱，用于表示开发者的信息

```shell
git config --global user.name "Your Name" 

git config --global user.email "email@example.com" 
```

> ==注意命令之间的空格==

可以使用 `git config -l `命令来查看配置信息

### 基本操作

Git 的起始操作包括以下几个步骤

1. 创建并进入空文件夹
2. 右键 -> 点击 Git Bash Here 启动命令行
3. `git init` 仓库初始化
4. 创建一个初始化文件 index.html
5. `git add index.html` 将文件加入到暂存区
6. `git commit -m '注释'`   提交到仓库  m 是 message 单词的缩写

![Git 步骤情况介绍](assets/Git 步骤情况介绍.jpg)

### .git 目录

![1576587724690](assets/1576587724690.png)

* hooks 目录包含客户端或服务端的钩子脚本，在特定操作下自动执行。
* info 信息文件夹. 包含一个全局性排除文件，可以配置文件忽略
* logs 保存日志信息
* objects <span style='color:red'>目录存储所有数据内容</span>,本地的版本库存放位置
* refs 目录存储指向数据的提交对象的指针（分支）
* config <span style='color:red'>文件包含项目特有的配置选项</span>
* description 用来显示对仓库的描述信息
* HEAD 文件指示目前被检出的分支
* index 暂存区数据 (git ls-files)

> 切记： <span style="color:red">不要手动去修改 .git 文件夹中的内容</span>

### 版本库的三个区域

* 工作区（代码编辑区）
* 暂存区（修改待提交区）
* 仓库区（代码保存区）

![img](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2469289094,3249956923&fm=26&gp=0.jpg)



### 常用命令

* ==git status== 版本状态查看
* ==git add -A== 添加所有新文件到暂存区
* ==git commit -m '注释 '== 提交修改并注释
* `git diff`  查看工作区与暂存区的差异（不显示新增文件） 显示做了哪些修改
* `git diff --cached` 查看暂存区与仓库的差异

### 历史版本回滚

#### 回滚

查看历史记录

```shell
git log
git log --oneline
```

> 如果内容偏多， 需要使用方向键上下滚动， 按 `q` 退出

根据版本号进行回滚   

```shell
git reset --hard  b815fd5a6ae655b521a31a9
```

> 进行版本回退时，不需要使用完整的哈希字符串，前七位即可
>
> ==版本切换之前，要提交当前的代码状态到仓库==

#### 找不到版本号的情况

查看所有的操作记录

```sh
git reflog
```

#### 其他回滚（了解）

```sh
git reset --hard HEAD^    回滚到上个版本
git reset --hard HEAD^^   回滚到上上个版本
```

### 配置忽略文件

##### 仓库中没有提交该文件

项目中有些文件是不需要进入版本库中，比如编辑器的配置。Git 中需要创建一个文件 ==.gitignore==，一般与 .gitignore 同级目录。

```sh
# 忽略所有的 .idea 文件夹
.idea
# 忽略所有以 .test 结尾的文件
*.test
# 忽略 node_modules 文件和文件夹
/node_modules
```

> .gitignore 可以在子文件夹下创建

##### 仓库中已经提交该文件

1. 对于已经加入到版本库的文件，可以在版本库中删除该文件

    ```sh
    git rm --cached .idea
    ```

2. 然后在 .gitignore 中配置忽略

    ```sh
    .idea
    ```

3. add  和 commit 提交即可

### 分支

分支是 Git 重要的功能特性之一，开发人员可以在主开发线的基础上分离出新的开发线。

#### 基本操作

##### 创建分支

name 为分支的名称

```sh
git branch name   
```

查看分支

```sh
git branch
```

##### 切换分支

```sh
git checkout name
```

##### 合并分支

```sh
git merge name
```

##### 删除分支

```sh
git branch -d name
```

##### 创建并切换分支

```sh
git checkout -b name
```

> 注意:  <span style="color:red">每次在切换分支前 提交一下当前分支</span>

#### 冲突

当多个分支修改同一个文件后，合并分支的时候就会产生冲突。冲突的解决非常简单，将内容修改为最终想要的结果，然后继续执行 git add 与 git commit 就可以了。



# GitHub

### 介绍

GitHub 是一个 Git 仓库管理网站。可以创建远程中心仓库，为多人合作开发提供便利。

### 使用流程

GitHub 远程仓库使用流程较为简单，主要有以下几种场景：

#### 本地有仓库

1. 注册并激活账号

2. 创建仓库

3. 获取仓库的地址

4. ==本地配置远程仓库的地址==
  
   ```shell
   git remote add origin https://github.com/xiaohigh/test2.git  
   //远端仓库管理
   add  添加
   origin 远端仓库的别名
   https://github.com/xiaohigh/test2.git    仓库地址
   ```
   
5. 本地提交（确认代码已经提交到本地仓库）

6. 将本地仓库内容推送到远程仓库
  
   ```shell
   git push -u origin master
   //
   push 推送
   -u   关联, 加上以后,后续提交时可以直接使用 git push
   origin 远端仓库的别名
   master 本地仓库的分支
   ```

#### 本地没有仓库

1. 注册并激活账号

3. 克隆仓库
  
   ```shell
   git clone https://github.com/xiaohigh/test2.git 
   ```
   
3. 增加和修改代码

4. 本地提交

   ```shell
   git add -A
   git commit -m 'message'
   ```

5. 推送到远程

   ```shell
   git push origin master
   ```

> 克隆代码之后， 本地仓库会默认有一个远程地址的配置， 名字为 origin

#### 多人合作

##### 账号仓库配置

GitHub 团队协作开发也比较容易管理，可以创建一个组织

- ==首页 -> 右上角 `+` 号-> new Organization==
- 免费计划
- 填写组织名称和联系方式（不用使用中文名称）
- 邀请其他开发者进入组织（会有邮件邀请）

* 点击组织右侧的 settings 设置
* 左侧 Member privileges
* 右侧 Base permissions 设置 write 👌

##### 协作流程

第一次

* 得到 Git 远程仓库的地址和账号密码

* 将代码克隆到本地（地址换成自己的）
  
  ```shell
  git clone https://github.com/xiaohigh/test.git
  ```
  
* 切换分支

  ```
  git checkout -b xiaohigh
  ```

* 开发代码 

* 本地提交

  ```shell
  git add -A
  git commit -m '注释内容'
  ```

* 合并分支

  ```shell
  git checkout master
  git merge xiaohigh
  ```

* 更新本地代码

  ```shell
  git pull
  //或者使用下面两行代码
  git fetch 
  git merge origin/master
  ```

* 提交代码

  ```shell
  git push 
  ```

##### 工作流程

第二次流程

1. 更新代码
2. 切换并合并分支
3. 开发功能
4. 提交
5. 合并分支
6. 提交本地代码
7. 更新代码
8. 提交代码

##### 冲突解决

同分支冲突一样的处理，将代码调整成最终的样式，提交代码即可。

##### <span style='color:blue'>免密登录</span>

1. 创建非对称加密对

    ```sh
    ssh-keygen -t rsa -C "xxx@xxx.com"
    ```

2. 文件默认存储在家目录（c:/用户/用户名/.ssh）的 .ssh 文件夹中。

   * id_rsa 私钥
   * id_rsa.pub 公钥

3. 将公钥（.pub）文件内容配置到账号的秘钥中

   ==首页 -> 右上角头像-> settings -> SSH and GPG keys -> new SSH Key==

4. 克隆代码时，选择 ssh 模式进行克隆 （地址 在仓库首页 绿色 克隆的位置 选择 use ssh）

   ```shell
   git clone git@github.com/xiaohigh/team-repo-1.git 
   ```



### GitFlow

GitFlow 是团队开发的一种最佳实践，将代码划分为以下几个分支

![img](assets/o_git-workflow-release-cycle-4maintenance.png)

- Master 主分支。上面只保存正式发布的版本
- Hotfix  线上代码 Bug 修复分支。开发完后需要合并回Master和Develop分支，同时在Master上打一个tag
- Feather 功能分支。当开发某个功能时，创建一个单独的分支，开发完毕后再合并到 dev 分支
- Release 分支。待发布分支，Release分支基于Develop分支创建，在这个Release分支上测试，修改Bug
- Develop 开发分支。开发者都在这个分支上提交代码

首次克隆完代码后，需要切换到开发分支

```sh
//查看所有分支
git branch -a
//切换分支
git checkout -b dev
```

## 附录

### Git 官方书籍

[https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6](https://git-scm.com/book/zh/v2/起步-关于版本控制)

### CRLF

CRLF 是Carriage-Return Line-Feed 的缩写。

CR 表示的是 ASCII 码的第 13 个符号 \r 回车，LF 表示的是 ASCII 码表的第 10 个符号 \n 换行。

每个操作系统对回车换行的存储方式不同

* windows 下用 CRLF（\r\n）表示
* linux 和 unix 下用 LF（\n）表示
* mac 系统下用 CR（\r）表示

![打字机](assets/打字机.jpg)

### 远程仓库配置

本地仓库经常需要进行远程仓库的推送和更新，本地仓库可以配置远程仓库别名便于操作，常用命令有

查看使用方法

```shell
git remote -h 
```

增加远程仓库

```shell
git remote add origin https://github.com/xiaohigh/learn.git
```

查看远程仓库配置

```
git remote -v
```



### 常见错误

#### 回车换行转换问题

```sh
warning: LF will be replaced by CRLF in 5.html.
The file will have its original line endings in your working directory
```

这个问题主要是 Git 在你提交时自动地把回车（CR）和换行（LF）转换成换行（LF），没有影响，==这里建议大家保留这个状态==。如果实在觉得警告难受，可以设置不转换

```sh
git config --global core.autocrlf false // 不推荐
```

### 提交报错

![img](assets/1532788288.bmp)

其他人已经提交过，本地代码需要更新，首先运行 git pull 命令



### 冲突提醒

![1574235172869](assets/1574235172869.png)

编辑冲突

### 提交错误

```sh
xiaohigh@DESKTOP-252ML8M MINGW64 /d/www/BJ0819/day13/代码/1-GitHub/7-test-ssh/8-https-to-ssh (master)
$ git push
fatal: The current branch master has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin master
```

如果第一次将本地仓库分支提交到远程时，直接使用 `git push` 可能会报这个错误，解决方法

```sh
git push -u origin master
```

### 提交错误

```
 refusing to merge unrelated histories
```

解决方法

```
git pull origin master --allow-unrelated-histories
```

### 提交错误

![1576840150520](assets/1576840150520.png)

当前所在文件夹不是一个 git 仓库目录，切换目录工作

### 找不到 .git 的方法

![1582943996890](assets/1582943996890.png)
# NODEJS
## 介绍

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是一个应用程序。

官方网址 <https://nodejs.org/en/>，中文站 <http://nodejs.cn/>

## 作用

- 解析运行 JS 代码
- 操作系统资源，如内存、硬盘、网络

## 应用场景

* APP 接口服务
* 聊天室
* 动态网站, 个人博客, 论坛, 商城
* 后端的Web服务，例如服务器端的请求（爬虫），代理请求（跨域）
* 前端项目打包

## 使用

### 下载安装

工具一定要到官方下载，历史版本下载 <https://npm.taobao.org/mirrors/node/>

#### 交互模式

在命令行下输入命令 `node`，这时进入 nodejs 的交互模式

#### 文件执行

创建文件 hello.js ，并写入代码 console.log('hello world')，命令行运行 `node hello.js`

快速启动命令行的方法

* 在文件夹上方的路径中，直接输入 cmd 即可
* 使用 webstorm 和 vscode 自带的命令行窗口



<span style="color:red">在 nodejs 环境下，不能使用 BOM 和 DOM ，也没有全局对象 window，全局对象的名字叫 global</span>



### Buffer(缓冲器)

#### 介绍

Buffer 是一个和数组类似的对象，不同是 Buffer 是专门用来保存二进制数据的

#### 特点

* 大小固定：在创建时就确定了，且无法调整
* 性能较好：直接对计算机的内存进行操作
* 每个元素大小为 1 字节（byte）

#### 操作

##### 创建 Buffer

* 直接创建 Buffer.alloc
* 不安全创建 Buffer.allocUnsafe

* 通过数组和字符串创建 Buffer.from

##### Buffer 读取和写入

可以直接通过 `[]` 的方式对数据进行处理，可以使用 toString 方法将 Buffer 输出为字符串

* ==[ ]== 对 buffer 进行读取和设置
* ==toString== 将 Buffer 转化为字符串

##### 关于溢出

溢出的高位数据会舍弃

##### 关于中文

一个 UTF-8 的中文字符大多数情况都是占 3 个字节

##### 关于单位换算

1Bit 对应的是 1 个二进制位

8 Bit = 1 字节（Byte）

1024Byte = 1KB 

1024KB = 1MB

1024MB = 1GB

1024GB = 1TB

平时所说的网速 10M 20M 100M 这里指的是 Bit ，所以理论下载速度 除以 8 才是正常的理解的下载速度

### 文件系统 fs

fs 全称为 file system，是 NodeJS 中的内置模块，可以对计算机中的文件进行增删改查等操作。

##### 文件写入

* 简单写入
  * fs.writeFile(file, data, [,options], callback);
  * fs.writeFileSync(file, data);
  * options 选项
    * `encoding` **默认值:** `'utf8'`
    * `mode`**默认值:** `0o666`
    * `flag` **默认值:** `'w'`
* 流式写入
  * fs.createWriteStream(path[, options])
    * path
    * options
      * ==flags==   **默认值:** `'w'`
      * `encoding `**默认值:** `'utf8'`
      * `mode`   **默认值:** `0o666`
    * 事件监听 open  close  eg:  ws.on('open', function(){});

##### 文件读取

* 简单读取
  * fs.readFile(file, function(err, data){})
  * fs.readFileSync(file)
* 流式读取
  * fs.createReadStream();

##### 文件删除

* fs.unlink('./test.log', function(err){});
* fs.unlinkSync('./move.txt');

##### 移动文件 + 重命名

* fs.rename('./1.log', '2.log', function(err){})
* fs.renameSync('1.log','2.log')

##### 文件夹操作

* mkdir  创建文件夹
  * path
  * options 
    * recursive 是否递归调用
    * mode  权限 默认为 0o777
  * callback 
* rmdir 删除文件夹
* readdir  读取文件夹

##### 关于fs的路径设置

* 可以是相对路径. 『./index.html』 『../index.html』
* 可以是绝对路径  『D:/index.html』『E:/www.index.html』
* 相对路径前要补充『__dirname』, 这样可以保证程序不受到执行位置的影响



## 附录

### unicode 字符集

* https://www.tamasoft.co.jp/en/general-info/unicode.html

* https://www.cnblogs.com/whiteyun/archive/2010/07/06/1772218.html    
# HTTP 协议



## 介绍

HTTP（hypertext transport protocol）协议也叫==超文本传输协议==，是一种基于 TCP/IP 的应用层通信协议，这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。

协议主要规定了两方面的内容

* 客户端向服务器发送数据，称之为==请求报文==
* 服务器向客户端返回数据，称之为==响应报文==

## Fiddle 工具

Fiddler 是一个http协议调试代理工具，使用它我们可以抓取网页的所有请求与响应，也就是咱们俗称的抓包。

![1573826028707](assets/1573826028707.png)

## 内容

### 请求

HTTP 请求报文包括四部分

* 请求行
* 请求头
* 空行
* 请求体

```http
GET http://localhost:3000/index.html?username=sunwukong&password=123123 HTTP/1.1
Host: localhost:3000
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9


```

*  GET http://localhost:3000/hello.html HTTP/1.1：GET请求，请求服务器路径为http://localhost:3000/hello.html，?后面跟着的是请求参数（查询字符串），协议是HTTP 1.1版本
*  Host: localhost:3000：请求的主机名为localhost，端口号3000
*  Connection: keep-alive：处理完这次请求后继续保持连接，默认为3000ms
*  Pragma: no-cache：不缓存该资源，http 1.0的规定
*  Cache-Control: no-cache： 不缓存该资源 http 1.1的规定，优先级更高
*  Upgrade-Insecure-Requests: 1：告诉服务器，支持发请求的时候不用 http 而用 https
*  User-Agent: Mozilla/5.0 (...：与浏览器和OS相关的信息。有些网站会显示用户的系统版本和浏览器版本信息，这都是通过获取User-Agent头信息而来的
*  Accept: text/html,...：告诉服务器，当前客户端可以接收的文档类型。q 相当于描述了客户端对于某种媒体类型的喜好系数，该值的范围是 0-1。默认为1
*  Accept-Encoding: gzip, deflate, br：支持的压缩格式。数据在网络上传递时，服务器会把数据压缩后再发送
* Accept-Language: zh-CN,zh;q=0.9：当前客户端支持的语言，可以在浏览器的工具选项中找到语言相关信息

### 请求报文

```
行      POST http://atguigu.com/home.html?a=100&b=200 HTTP/1.1
头      Host: atguigu.com
        User-Agent: chrome firefox 
        Connection: keep-alive

体      username=yuxiang&password=hejia 
```

请求体的内容格式也是灵活的. 常见的有两种类型

* 查询字符串形式    username=yuxiang&password=hejia
* JSON 格式        {"username":"yuxiang", "password":"hejia"}

### 响应

HTTP 响应报文也包括四个部分

- 响应行
- 响应头
- 空行
- 响应体

```http
HTTP/1.1 200 OK
X-Powered-By: Express
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Wed, 21 Mar 2018 13:13:13 GMT
ETag: W/"a9-16248b12b64"
Content-Type: text/html; charset=UTF-8
Content-Length: 169
Date: Thu, 22 Mar 2018 12:58:41 GMT
Connection: keep-alive

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>首页</title>
</head>
<body>
  <h1>网站首页</h1>
</body>
</html>
```

*  HTTP/1.1 200 OK：协议是HTTP 1.1版本，请求响应成功
*  X-Powered-By: Express：自定义的头，表示用的框架，一般不返回容易造成安全漏洞。
*  Accept-Ranges: bytes：告诉浏览器支持多线程下载
*  Cache-Control: public, max-age=0：强制对所有静态资产进行缓存，即使它通常不可缓存。max-age指定多久缓存一次
*  Last-Modified: Wed, 21 Mar 2018 13:13:13 GMT：这个资源最后一次被修改的日期和时间
*  ETag: W/"a9-16248b12b64"：请求资源的标记/ID
*  Content-Type: text/html; charset=UTF-8：返回响应体资源类型
*  Content-Length: 169：响应体的长度
* Date: Thu, 22 Mar 2018 12:58:41 GMT：提供了日期的时间标志，标明响应报文是什么时间创建的



### 响应报文

```
行      HTTP/1.1 200 OK
头      Content-Type: text/html;charset=utf-8
        name: H5200422
        type: gaofushuaibaifumei
        Connection: keep-alive
空行
体      <!doctype html>
        <html>
            <head>
                <meta charset="utf-8">
            </head>
            <body>

            </body>
        </html>
```



### WEB 服务

使用 nodejs 创建 HTTP 服务器

```js
//1. 引入 http 内置模块
var http = require('http');

//2. 创建服务
var server = http.createServer(function(request, response){
    response.end('hello world!!');
});

//3. 监听端口
server.listen(8000);
```

* request 是对请求报文的封装对象
* response 是对响应的封装对象

#### 获取请求

```js
//获取请求方法
console.log(request.method);

//获取http版本
console.log(request.httpVersion);

//获取请求路径
console.log(request.url);

//获取请求头
console.log(request.headers);

//获取请求体
request.on('data', function(chunk){})
request.on('end', function(){});
```

#### 设置响应

```js
//设置状态码
response.statusCode = 200;

//设置响应头
response.setHeader('content-type','text/html;charset-utf-8');

//设置响应体
response.write('body');

//结束
response.end();

```

#### 直接ip或域名访问

比如 http://127.0.0.1:8000 此时路径为 『/』
http://www.baidu.com       此时路径为 『/』

## GET和POST使用场景

### GET

* 地址栏直接输入 URL 访问
* a 链接
* link href 
* script 标签 src 
* img  src  
* form 表单 method="GET" 的情况
* AJAX GET 类型



### POST

* 表单 form method="POST"  登录 注册 个人信息 
* AJAX POST 类型



### GET和POST区别

1. 用途: GET 一般用来获取数据, POST 一般用来提交并添加数据
2. 传参: GET 传参是将参数放置到 URL 的后边连接, POST 传参是将参数放置到请求体中 
3. 安全性: GET 参数会暴露在 url 中,相对不安全, POST 因为请求体直接不可见, 所以相对安全
4. 参数体积: GET 传参体积限制一般限制为 2k, POST 没有这个限制
5. 协议中请求行的第一段内容不一样



## 页面的路径

绝对路径

```js
/index.html
/css/app.css
```

> ​	绝对路径不受页面 url 路径影响, 发送请求时, 报文的 URL 就是绝对路径

相对路径

```js
./index.html
./css/app.css
../css/home.css
js/app.js
```

>相对路径要收到页面 url 路径的影响.
>例如:
>页面的url 为 xxx.com/page/index.html , 页面中link标签为 『./css/app.css』, 
>那么发送 GET 请求获取 CSS 资源的时候, 报文的 URL 为 『/page/css/app.css』

## 附录

### 响应状态码

响应状态码是服务器对结果的标识，常见的状态码有以下几种：

- 200：请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；
- 301：重定向，被请求的旧资源永久移除了（不可以访问了），将会跳转到一个新资源，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址；
- 302：重定向，被请求的旧资源还在（仍然可以访问），但会临时跳转到一个新资源，搜索引擎会抓取新的内容而保存旧的网址；
- 304：（Not Modified）请求资源未被修改，浏览器将会读取缓存；
- 403：forbidden 禁止的
- 404：请求的资源没有找到，说明客户端错误的请求了不存在的资源；
- 500：请求资源找到了，但服务器内部出现了错误；

  

### Sec-Fetch-* 请求头

<https://www.w3.org/TR/fetch-metadata/#sec-fetch-mode-header>

# NPM

### 介绍

全称：Node Package Manager , Node 的包管理器，也是一个应用程序。

### 包是什么

Node.js 的包基本遵循 CommonJS 规范，将一组相关的模块组合在一起，形成一个完整的工具

### 作用

通过 NPM 可以对 Node 的工具包进行搜索、下载、安装、删除、上传。借助别人写好的包，可以让我们的开发更加方便。

### 安装

安装完 nodejs 之后会自动安装 npm

### 常用命令

#### 查看 npm 的版本

```sh
npm -v 
```

#### 初始化

```sh
npm init
npm init --yes
```

运行后会创建 package.json 文件

```json
{
  "name": "1-npm",      #包的名字
  "version": "1.0.0",   #包的版本
  "description": "",    #包的描述
  "main": "index.js",   #包的入口文件
  "scripts": {			#脚本配置
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",			#作者
  "license": "ISC"		#版权声明
}
```

> ==注意生成的包名不能使用中文，大写 ！！！==

关于开源证书扩展阅读

<http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html>

#### 搜索包

```sh
npm search jquery
npm s jquery
```

一般在搜索工具包的时候，会到 https://npmjs.org 搜索

#### 安装工具包

```sh
npm install jquery
npm i jquery

# 安装并在 package.json 中保存包的信息(dependencies 属性)
npm install jquery --save
npm install jquery -S

# 安装并在 package.json 中保存包的信息(devDependencies 属性)
npm install babel --save-dev
npm install babel -D
```

>  6 版本的 npm ，安装包时会自动保存在 dependencies 中，可以不用写 --save，不过为了适应旧版本，建议写的时候加上 --save

#### 全局安装

```sh
npm install less -g
npm install babel -g
```
## 全局安装
* 不会放置到文件夹下的 node_modules 目录下. 
* 在任意一个命令行的文件夹下都可以执行该命令
## 环境变量 Path
1. 此电脑右键 -> 属性
2. 左侧高级系统设置
3. 点击 『高级』
4. 下边点击『环境变量』
5. 双击 『Path』
6. 右侧『新建』
7. 将路径添加到新的input框中
8. 一路确定 -> 搞定😎

全局安装一般用于安装全局工具，如 cnpm，yarn，webpack 等，全局命令的安装位置

```
C:\Users\xiaohigh\AppData\Roaming\npm
```

#### 安装依赖

根据 package.json 中的依赖声明， 安装工具包
* dependencies          生产依赖(生产 线上环境)   -S  --save
* devDependencies       开发依赖(开发环境, 打包)  -D  --save-dev

```sh
npm i
npm install
npm i --production // 只安装 dependencies 中的依赖
```

#### 移除包

```sh
npm remove jquery
```



### 使用流程

#### 独立开发

独立开发时使用流程

1. npm init 初始化
2. npm i     安装工具包
3. 代码中使用 require 的形式使用即可
4. 版本控制中将 node_modules 设置不监控

#### 团队协作

团队开发时使用流程

1. 从仓库中拉取仓库代码
2. 运行 npm install 安装相关依赖
3. 运行项目，继续开发

### 封装 NPM 包

创建自己的 NPM 包可以帮助代码进行迭代进化，使用步骤也比较简单

1. 创建文件夹，并创建文件index.js， 在文件中声明函数，使用 module.exports 暴露
2. npm 初始化工具包，package.json 填写包的信息
3. 账号注册（激活账号）
4. npm login 填写相关用户信息
5. npm publish 提交包 👌

> npm 有垃圾检测机制，如果名字简单或做测试提交，很可能会被拒绝提交
>
> ==可以尝试改一下包的名称来解决这个问题==

### CNPM

#### 介绍

cnpm 是淘宝对国外 npm 服务器的一个完整镜像版本，也就是淘宝 npm 镜像，网站地址<http://npm.taobao.org/>

#### 安装

安装配置方式有两种

* npm install -g cnpm --registry=https://registry.npm.taobao.org
* alias cnpm="npm --registry=https://registry.npm.taobao.org \
  --cache=$HOME/.npm/.cache/cnpm \
  --disturl=https://npm.taobao.org/dist \
  --userconfig=$HOME/.cnpmrc"

#### 使用

配置完成后，就可以使用 cnpm 命令来管理包，使用方法跟 npm 一样

```sh
cnpm install lodash
```

### Yarn

#### 介绍

yarn是Facebook开源的新的包管理器，可以用来代替npm。

#### 特点

yarn 相比于 npm 有几个特点

* 本地缓存。安装过的包下次不会进行远程安装
* 并行下载。一次下载多个包，而 npm 是串行下载
* 精准的版本控制。保证每次安装跟上次都是一样的

#### 安装

只需要一行命令即可安装 yarn

```sh
npm install yarn -g
```

#### 相关命令

yarn 的相关命令

1)  yarn --version

2)  yarn init  //生成package.json   

3) ==yarn global add  package (全局安装)==

4)  yarn add package (局部安装)

5)  yarn add package --dev (相当于npm中的--save-dev)

6)  yarn remove package

7)  yarn list //列出已经安装的包名

8)  yarn info packageName //获取包的有关信息

9)  yarn //安装package.json中的所有依赖

> npm 5 引入离线缓存，提高了安装速度，也引入了 package-lock.json 文件增强了版本控制

### CYarn

跟 npm 与 cnpm 的关系一样，可以为 yarn 设置国内的淘宝镜像，提升安装的速度

```sh
npm install cyarn -g --registry "https://registry.npm.taobao.org"
```

配置后，只需将yarn改为cyarn使用即可



### 附录

#### 关于版本号

版本格式：主版本号.次版本号.修订号

* "^3.0.0" ：锁定大版本，以后安装包的时候，保证包是3.x.x版本，x默认取最新的。
* "~3.1.x" ：锁定小版本，以后安装包的时候，保证包是3.1.x版本，x默认取最新的。
* "3.1.1" ：锁定完整版本，以后安装包的时候，保证包必须是3.1.1版本。
# 静态资源服务

## 目标
封装一个 NPM 包，可以全局运行，可以局部安装，实现静态资源服务

## 功能介绍

### 全局安装
1. 默认启动
    ```shell script
    # giao-server
    ```

2. 带参数启动
    ```shell script
    # giao-server --port=8000
    ```

### 局部安装
1. 基本使用
    ```js
    const Server = require('giao-server');
    
    const server = new Server();
    
    server.run();
    ```

2. 传参使用
    ```js
    const Server = require('giao-server');
    
    const server = new Server({port:8080, root: './public'});
    
    server.run();
    ```

## 相关知识点

### mime类型

```json
{
    "css":"text/css",
    "gif":"image/gif",
    "html":"text/html;charset=utf-8",
    "ico":"image/x-icon",
    "jpeg":"image/jpeg",
    "jpg":"image/jpeg",
    "js":"text/javascrip;charset=utf-8",
    "json":"application/json;charset=utf-8",
    "pdf":"application/pdf",
    "png":"image/png",
    "svg":"image/svg+xml",
    "swf":"application/x-shockwave-flash",
    "tiff":"image/tiff",
    "txt":"txt/plain;charset=utf-8",
    "wav":"audio/x-wav",
    "wma":"audio/x-ms-wma",
    "wmv":"video/x-ms-wmv",
    "xml":"text/xml"
}
```

### 代码打开浏览器

```js
const child_process = require('child_process');

module.exports = function (url) {
    let cmd = '';
    if (process.platform == 'win32') {
        cmd = 'start chrome';
    } else if (process.platform == 'linux') {
        cmd = 'xdg-open';
    } else if (process.platform == 'darwin') {
        cmd = 'open';
    }
    child_process.exec(`${cmd} "${url}"`);
}
```

## 创建一个全局命令
1. 创建单独文件
```sh
#!/usr/bin/env node
```

2. 在 package.json 文件中配置 bin 字段
```
"bin": {
    "html": "./bin/cmd"
}
* html 命令的名称
* ./bin/cmd 新建的文件
```

3. 上传工具包
4. 全局安装
```shell
npm install giao-server -g
```

# 缓存
## 介绍

* 缓存可以重用已获取的资源能够有效的提升网站与应用的性能
* Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间
* 借助 HTTP 缓存，Web 站点变得更具有响应性
* 缓存分为两点：
  * 强制缓存
  * 协商缓存

## 强制缓存
### 概念

强制缓存就是在浏览器缓存该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。

简单来讲就是强制浏览器使用当前缓存

### 实现

通过服务器端设置响应头字段来控制

* expires (http1.0)
* cache-control (http1.1)
* cache-control 优先级比 expires 高

#### expires

日期（new Date().toGMTString()） 缓存的过期时间

#### cache-control

* max-age(单位s)   缓存的最大有效时间
* no-cache        使用协商缓存
* no-store        不使用任何缓存
* public          （客户端、代理服务器）缓存所有资源
* private         默认值，只有客户端缓存所有资源

## 协商缓存
### 概念

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

### 实现

借助响应头和请求头来实现

服务器端给客户端返回

* Last-modified        记录服务器返回资源的最后修改时间
* Etag                         当前文件的唯一标识（由服务器生成）

客户端给服务器端请求

* If-Modified-Since   记录服务器返回资源的最后修改时间
* If-None-Match	   当前文件的唯一标识（由服务器生成）
> Etag / If-None-Match 优先级比 Last-Modified / If-Modified-Since 高。

### 工作流程

* 第一次：由服务器返回 Etag  和 Last-modified 字段通过响应头方式返回
* 第二次：下次浏览器请求时，携带了If-None-Match（值为上一次的 Etag 的值）和If-Modified-Since（值为上一次的 Last-modified 的值）发送给服务器
* 服务器检查 If-None-Match 是否等于最新 Etag 的值，如果相等直接走浏览器缓存，不相等就返回新的资源
* 如果没有 If-None-Match，才看 If-Modified-Since 的值，检查 If-None-Since 是否等于最新的 Last-modified  的值，如果相等直接走浏览器本地缓存，不相等就返回新的资源

## 缓存返回值
* 200(from memory cache)
	* 命中强制缓存
	* 缓存来自于内存
* 200(from disk cache)
	* 命中强制缓存
	* 缓存来自于磁盘
* 304 Not Modified
	* 命中协商缓存
* 200 
	* 没有命中缓存

## 操作对缓存的影响

| 浏览器操作              | 强制缓存 | 协商缓存 |
| ----------------------- | -------- | -------- |
| 地址栏回车              | √        | √        |
| 页面链接跳转（a 链接）  | √        | √        |
| 新开窗口（window.open） | √        | √        |
| 前进、后退              | √        | √        |
| 刷新（ctrl + r 和 F5）  | X        | √        |
| 强制刷新（ctrl + F5）   | X        | X        |

# AJAX

## 原生AJAX

### AJAX 简介

AJAX 全称为Asynchronous Javascript And XML，就是异步的 JS 和 XML。

通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。

AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。

### XML简介

XML 可扩展标记语言。

XML 被设计用来传输和存储数据。

XML和HTML类似，不同的是HTML中都是预定义标签，而XML中没有预定义标签，全都是自定义标签，用来表示一些数据

### AJAX的特点

####  AJAX的优点

*  可以无需刷新页面而与服务器端进行通信。
* 允许你根据用户事件来更新部分页面内容。

#### AJAX的缺点

*  没有浏览历史，不能回退
*  存在跨域问题
* SEO不友好

###  AJAX的使用

#### 核心对象

XMLHttpRequest，AJAX的所有操作都是通过该对象进行的。

####  使用步骤

* 创建XMLHttpRequest对象

  ```js
  var xhr = new XMLHttpRequest();
  ```

* 设置请求信息

* ```js
  xhr.open(method, url);
  ```

* 发送请求

  * xhr.send(body) //get请求不传body参数，只有post请求使用

* 接收响应

  * xhr.responseXML 接收xml格式的响应数据
  * xhr.responseText 接收文本格式的响应数据

* ```js
  xhr.onreadystatechange = function (){
      if(xhr.readyState == 4 && xhr.status == 200){
          var text = xhr.responseText;
          console.log(text);
  
  ```

### 解决IE缓存问题

问题：在一些浏览器中(IE),由于缓存机制的存在，ajax只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。

解决方式：浏览器的缓存是根据url地址来记录的，所以我们只需要修改url地址即可避免缓存问题

```js
xhr.open("get","/testAJAX?t="+Date.now());
```

### AJAX请求状态

xhr.readyState 可以用来查看请求当前的状态

0: 表示XMLHttpRequest实例已经生成，但是open()方法还没有被调用。

1: 表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息。

2: 表示send()方法已经执行，并且头信息和状态码已经收到。

3: 表示正在接收服务器传来的body部分的数据。

4: 表示服务器数据已经完全接收，或者本次接收已经失败了

## jQuery中的AJAX

### get请求

```js
$.get(url, [data], [callback], [type])
url:请求的URL地址。
data:请求携带的参数。
callback:载入成功时回调函数。
type:设置返回内容格式，xml, html, script, json, text, _default。

```

### POST请求

```
$.post(url, [data], [callback], [type])
url:请求的URL地址。
data:请求携带的参数。
callback:载入成功时回调函数。
type:设置返回内容格式，xml, html, script, json, text, _default。

```

## 跨域

* 同源策略

  同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是浏览器的一种安全策略。

  同源： 协议、域名、端口号 必须完全相同。

  违背同源策略就是跨域。

### 如何解决跨域问题

方法一jsonp

*  JSONP是什么

  * JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get请求。

* JSONP怎么工作的？

  * 在网页有一些标签天生具有跨域能力，比如：img link iframe script。

    JSONP就是利用script标签的跨域能力来发送请求的。

* JSONP的使用

  * 动态的创建一个script标签

    * ```js
      var script = document.createElement("script");
      ```

  * 设置script的src，设置回调函数

    * ```
      script.src = "http://localhost:3000/testAJAX?callback=abc";
      function abc(data) {
      	alert(data.name);
      };
      
      ```

  * 将script添加到body中

    * ```js
      document.body.appendChild(script);
      ```

  * 服务器中路由的处理

    * ```js
      router.get("/testAJAX" , function (req , res) {
      	console.log("收到请求");
      	var callback = req.query.callback;
      	var obj = {
              name:"孙悟空",
      		age:18
      	}
      	res.send(callback+"("+JSON.stringify(obj)+")");
      });
      
      
      ```

*  jQuery中的JSONP

  * ```js
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>Title</title>
    </head>
    <body>
      <button id="btn">按钮</button>
      <ul id="list"></ul>
      <script type="text/javascript" src="./jquery-1.12.3.js"></script>
      <script type="text/javascript">
        window.onload = function () {
          var btn = document.getElementById('btn')
          btn.onclick = function () {
            $.getJSON("http://api.douban.com/v2/movie/in_theaters?callback=?",function (data) {
              console.log(data);
              //获取所有的电影的条目
              var subjects = data.subjects;
              //遍历电影条目
              for(var i=0 ; i<subjects.length ; i++){
                $("#list").append("<li>"+
                  subjects[i].title+"<br />"+
                  "<img src=\""+subjects[i].images.large+"\" >"+
                  "</li>");
              }
            });
          }
        }
      </script>
    </body>
    </html>
    
    ```



放法二

CORS

* CORS是什么？

  * CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get和post请求。

*  CORS怎么工作的？

  * CORS是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。

* CORS的使用

  * 主要是服务器端的设置：

  * ```
    router.get("/testAJAX" , function (req , res) {
    	//通过res来设置响应头，来允许跨域请求
    	//res.set("Access-Control-Allow-Origin","http://127.0.0.1:3000");  
    	res.set("Access-Control-Allow-Origin","*");
    	res.send("testAJAX返回的响应");
    });
    
    ```

    

# 模块化



## 介绍

模块化指的就是将一个大的功能拆分为一个一个小的模块，通过不同的模块的组合来实现一个大功能。

- 在node中一个 js 文件就是一个模块
- 模块内部代码对于外部来说都是不可见的，可以通过两种方式向外部暴露



## 模块创建

一、创建 JS 文件，编写代码（假设当前文件名为 test.js）

```js
function test(){
	console.log('test');
}
```

二、在文件中对外暴露

```js
module.exports = test;
```

这里有几点注意：

* module.exports 可以暴露任意数据
* 可以使用 module.exports 暴露多个数据
* exports 也可以暴露数据，不过不能使用 `exports = xxx` 的形式



## 模块引入

使用 require 引入文件即可

```js
var test = require('./test.js');
```

这里有几点注意：

* 如果没有加文件后缀，会按照以下后缀加载文件
  * .js    fs模块同步读取文件编译执行
  * .json  fs模块同步读取文件，用JSON.parse()解析返回结果
  * .node 这是c/c++编写的扩展文件，通过dlopen()方法编译
  * 其他扩展名  会以.js文件载入
* 如果是文件夹则会默认加载该文件夹下 package.json 文件中 main 属性对应的文件
* 如果 main 属性对应的文件不存在，则自动找 index.js  index.json 
* 如果是内置模块或者是 npm 安装的模块，直接使用包名字即可
* npm 引入包时，如果当前文件夹下的 node_modules 没有，则会自动向上查找



## 简化

导出

```
module.exports       
```

导入

```
var res = require('./module.js');
```

npm

在项目的文件件下创建 package.json 和 node_modules





