# 第一天

## 命令行

* 之前操作计算机通常都是通过图形化界面的形式来完成的（GUI）
* UI（User Interface）用户接口，用户通过接口来使用程序（设备）
* 命令行实际就是通过文字指令的来完成对计算机的操作（TUI）
* 命令行有很多的名字：命令行、CMD窗口、Terminal、终端、Shell ...

### 命令行的使用

1. 打开命令行
   * 使用 win + r 输入 cmd 回车
2. 命令行窗口的结构
   * 当前所在的路径
   * 命令提示符
3. 常用的命令
   1. dir，显示当前目录下的内容
   2. cd，跳转到指定的目录
      * 在路径中，.表示当前当前目录，..表示上一级目录
   3. mkdir，创建一个新的文件夹
   4. rmdir，删除一个文件夹
   5. del，删除一个文件（慎用）

## 版本控制（Version Control）

* 版本控制是指对软件开发过程中各种代码，配置文件及说明文档等文件变更的管理。

* 版本控制有点类似于游戏的存储进度，通过版本控制工具可以存储代码的编写的进度，可以根据需要恢复代码到指定的状态。

* 版本控制工具有很多种，今天要讲的一种版本控制工具叫做Git

* git的安装：

  * 下载，双击安装
  * 注意：

* git的使用：

  * 基本的配置（通常只需配置一次）

    * 配置用户名

      ```powershell
      git config --global user.name "用户名"
      ```

    * 配置电子邮件

      ```powershell
      git config --global user.email "电子邮件"
      ```

      

  * 使用

    * 初始化项目，将项目交给git维护
      * 进入到项目目录
      * 初始化项目，使git对代码进行管理

  * 查看代码的状态

    ```powershell
    git status
    ```

    

  * 使git对文件进行追踪

  * 追踪当前目录下所有文件

    ```powershell
    git add .
    ```

    

  * 将代码存储到仓库中（存储进度）

    ```powershell
    git commit
    ```

    * 如果使用的是vim编辑器，输入内容，然后Esc，然后输入:wq回车

  * 将代码存储到仓库中，并直接设置描述信息

    ```powershell
    git commit -m '设置描述信息'
    ```

    

  * 提交所有的已被追踪的文件

    ```powershell
    git commit -a -m '描述的信息'
    ```

    

  * 查看提交的日志

    ```powershell
    git log
    ```

    

  * 加载指定版本的代码

    ```powershell
    git checkout 版本
    ```

    

* 远程的Git库

  * 在真正的开发项目时，Git仓库一定不是仅仅存在于本地计算机，一定会有一个公共的服务器用来存储代码，公共服务器可以满足多人开发的需求。

  * 在公司时，一般公司都会有自己的Git的服务器，用来存储代码。但是我们现在处于学习阶段，所以我们可以直接使用一些公共的Git仓库来学习远程Git的操作

  * 这几天我们使用国内的代码托管平板，来学习git的操作 https://gitee.com/

  * 远程库的操作

    * 复制远程的仓库：

      * ```powershell
        git clone 仓库的地址
        ```

        

    * 向远程仓库推送代码（上传）

      * 向服务器推送代码前，先用拉取一下服务器中的最新代码

      * ```powershell
        git push
        ```

        

    * 从远程仓库中拉取最新代码（下载）

      * ```powershell
        git pull
        ```

        

    * 记住用户的权限信息

      * ```powershell
        git config --global credential.helper wincred
        ```

        

    * 取消记录用户的权限信息

      * ```powershell
        git credential-manager uninstall
        ```

        

# 第二天

## JS简介

* JS是由网景公司设计，起初被称为LiveScript，后来由于sun的介入，改名为JavaScript
* JS是一个动态类型的，面向对象的脚本语言（解释型语言）
* JS设置之初主要用于前端的验证，但是时至今日，JS的功能越来越强大，甚至已经延伸到了服务器端，现在来讲，JS和Java、Python这些语言没有本质的区别。

## JS的基本语法

### 编写位置

​	1.将JS代码，编写到script标签中

```html
		<script>
			// 编写js代码
		</script>
```
2.将js代码编写到一个外部的js文件中，然后通过script标签进行引入

```html
		<script src="xxx.js"></script>
```

3.可以将js代码编写到标签的指定属性中

```html
<button onclick="js代码">按钮</button>
<a href="javascript:js代码;">超链接</a>
```

## 变量和字面量			

### 变量（标识符）

* 变量可以用来存储字面量

* js中的变量没有类型的概念，可以存储任意类型的值

* 在使用过程中，也可以任意的为变量进行重新赋值

* 变量的使用：

  * 变量的声明

    ```javascript
    var 变量名;
    ```

  * 变量的赋值

    ```javascript
    变量名 = 变量值;  
    ```

  * 例子

    ```javascript
      var a;
      a = 100;
    ```

    

    

# 第三天

## 数据类型

### 基本数据类型

- 在JS中一共有5种常用的基本数据类型：

  - 数值（Number）

    - 在JS中所有的数字（整数和浮点数）都属于数值类型

    - 例子：

      - 123
      - 3.1415926
      - ±Infinity （无穷）
      - NaN（Not a Number）非数字

    - 使用typeof去检查一个数值时会返回 "number"

    - 在JS中，能保证大部分的整数计算能得到一个精确的结果，小数计算时可能会得到一个近似结果，所以如果对于计算的精度要求过高（尤其涉及到钱了）千万不要在这算。

    - 其他进制的数值：

      - 二进制：0b 开头
      - 八进制：0o开头
      - 十六进制：0x开头

    - 数字可以使用分隔符来表示

      - ```javascript
        var a = 123_456_789;
        ```

    - 类型转换，其他的数据类型转换为Number

      - 显式类型转换（强制类型转换）

        1. Number()

           ```javascript
           var a = '10';
           a = Number(a);
           ```

        2. parseInt()（对付字符串）

           - 用来将一个字符串转换为一个整数

        3. parseFloat() (对付字符串)

           - 用来将一个字符串转换为一个小数
           - 原理：对字符串自左向右解析，获取所有的合法的数字

      - 隐式类型转换（自动类型转换）(❤)

        - 使用一元的+（原理和Number()一样，使用起来更加简单）

        - ```javascript
          var a = '10';
          a = +a;
          ```

      - 类型转换的情况：

        - 字符串：
          - 字符串是一个合法的数字，则直接转换为对应的数字。
          - 字符串不是一个合法的数字，则转换NaN
          - 空串和空格串都会转换为0
        - 布尔值：
          - true 转换为 1
          - false 转换为 0
        - null 转换为 0
        - undefined 转换为 NaN
      - 隐式类型转换    ！！取反2次
  
- 字符串（String）
  
  - 在JS中字符串需要使用引号引起来
  
  - 使用typeof检查一个字符串，会返回"string"
  
  - 双引号或单引号都行，但是不要混着用
  
  - 相同的引号之间时不能嵌套的
  
  - 转义字符（\）：
  
      - \\'   表示 '
      - \\\"  表示 "
      - \\\\  表示 \\
      - \\t  表示 制表符  
    - \\n 表示 换行
  
  - 类型转换（其他类型转换为String）：
  
    - 显式类型转换（强制）
  
        - String()函数
        - toString()方法
        - 对于null和undefined来说，调用toString()会报错！
  
    - 隐式类型转换（自动）❤
  
      - 可以通过为任意值加一个空串的形式来将其转换为字符串
  
        - ```javascript
          var a = 10;
          a = a + "";
          ```
    ```
        
        
    ```
  
  - 布尔值（Boolean）
    - 布尔值主要用来进行逻辑判断
    - 使用typeof检查一个布尔值，会返回 "boolean"
    - 布尔值只有两个：
      - true，表示真
      - false，表示假
    - 类型转换：
      - 显式
        - 使用Boolean()函数
      - 隐式
        - 还没讲
    - 类型转换的情况 ❤：
      - 会被转换为false的情况：
        - null
        - undefined
        - 0
        - NaN
        - 空串
  - 空值（Null）
    - 空值用来表示空的对象
    - 只有一个值 null
    - 使用typeof 检查一个null时，会返回 "object"
  - 未定义（Undefined）
    - 未定义用来表示声明了却没有赋值的变量
    - 只有一个值 undefined
    - 使用typeof检查一个undefined时，会返回 "undefined"

## 运算符（操作符 operator）

-  通过运算符可以对一个或多个值进行运算或操作

### 算术运算符

- \+ 加法运算
- \- 减法运算 
- \* 乘法运算
- / 除法运算
- % 取模运算（两个数相除，取余数）
- ** 幂运算（求一个数的几次方）
- 注意：
  - 除了字符串的加法，所有的非Number类型的值进行算术运算时，都会先转换为Number然后再运算。
  - 任何值和NaN做运算结果都是NaN（除了字符串加法）
  - 两个字符串相加时，会自动将两个字符串连接为一个字符串，即所谓的拼串。
  - 任意值和字符串做加法时，都会转换为字符串然后在进行拼串操作。

### 一元运算符

- 一元运算符指只有一个操作数的运算符
  - 一元的+
    - 正号，它不会对数值产生任何影响，但是它会将非数值转换为数值
  - 一元的-
    - 负号，它会对数值进行符号位取反，正变负，负变正，同样也会将非数值转换为数值

# 第四天

## 运算符

### 自增和自减

* 自增（++）
  * 自增分为前++（++a）和后++ （a++）
  * a++可以使变量增加1，并且返回变量的原值 （自增前的值）
  * ++a可以使变量增加1，并且返回变量的新值 （自增前的值）
* 自减 （--）
  * 自减分为前-- （--a） 和后-- （a--）
  * a--可以使变量减1，并且返回变量的原值 （自减前的值）
  * --a可以使变量减少1，并且返回变量的新值 （自减后的值）

### 逻辑运算符

* ！逻辑非
  * 可以对一个布尔值进行取反操作，true变false，false变true
  * 如果是一个非布尔值，则会先将其转换为布尔值，然后再取反
  * 可以通过为一个值取反俩次，来将其转换为布尔值
* &&逻辑与
  * 对于布尔值：
    * 当俩侧的布尔值都为true时，返回true，否则返回false。
    * 与运算是短路的与，如果第一个值是false，则不看第二个值。
  * 对于非布尔值：
    * 对于非布尔值，它会将其转换为布尔值，然后运算最终返回原值。
    * 运算规则：如果第一值是true，则返回第二值，否则返回第一个。
* ||逻辑或
  * 对于布尔值：
    * 当俩侧的布尔值都为false时，返回false，否则返回true。
    * 或运算时短路的或，如果第一个值是true，则不看第二个值。
  * 对于非布尔值：
    * 对于非布尔值，它会将其转换为布尔值，然后运算最终返回原值。
    * 运算规则：如果第一个值是true，则返回第一个值，否则返回第二个。

### 关系运算符

* 关系运算符用来比较两个值之间的大小关系是否成立，如果关系成立返回true，不成立返回false

  * \> ，检查左侧值是否大于右侧值
  * \< ，检查左侧值是否小于右侧值
  * \>= ， 检查左侧值是否大于或等于右侧值
  * \<=， 检查左侧值是否小于或等于右侧值

* 特殊情况：

  * 如果比较的是非数字的值，解析器会将其转换为数值然后进行比较。

  * ```javascript
    10 > true // true
    10 < '5'  // false
    null > -10 // true
    ```

  * 如果比较的是两个字符串，此时解析器会逐位的比较字符的Unicode编码，利用这个特点可以对字符串按照字母顺序排序（对于中文意义不是很大）。

### 相等运算符

* ==（相等）
  * 用来比较两个值是否相等，相等返回true，不相等返回false
  * 相等运算符在进行比较时，会做自动的类型转换，如果两个值转换后相等，也会返回true
  * 通常情况下，类型转换时都会转换为数字，然后再比较
  * null 和 undefined做相等判断时，会返回true
* !=（不相等）
  * 用来比较两个值是否不相等，不相等返回true，相等返回false
  * 不等运算符在进行比较时，会做自动的类型转换，如果两个值转换后相等，也会返回false
* ===（全等）
  * 用比较两个值是否全等，它不会做自动的类型转换，如果两个值的类型不同，直接返回false
  * null 和 undefined 做全等比较时，会返回false
* !==（不全等）
  * 用来比较两个值是否不全等，它不会做自动的类型转换，如果两个值的类型不同，直接返回true
* 特殊情况：
  * NaN不和任意的值相等（包括自己），所有的值和NaN作比较时都会返回false
  * 可以通过isNaN()函数，来检查一个值是否是NaN

### 赋值运算符

* =
  * 将等号右侧的值赋值给等号左侧的变量
* +=
  * a += b 相当于 a = a + b
* -=
  * a -= b 相当于 a = a - b
* *=
  * a *= b 相当于 a = a * b
* /=
  * a /= b 相当于 a = a / b
* %=
  * a %= b 相当于 a = a % b
* **=
  * a \**= b 相当于 a = a ** b
* 可能会导致变量发生变化的情况（改变量）：
  * 使用赋值运算符
  * 使用自增或自减

### 条件运算符（三元运算符）

* 语法：条件表达式?语句1:语句2

* 执行顺序：

  * 条件运算符执行时，会先对条件表达式进行求值判断，如果判断结果为true，则执行语句1，如果判断结果为false，则执行语句2

* 例子：求两个值中的较大值：

* ```javascript
  var a = 10;
  var b = 20;
  var max = a > b ? a : b;
  ```

### 运算符的优先级

* 每一个运算符都有不同的优先级，优先级的大小根据优先级的表格查询，优先级高的优先计算，优先级一样的按照自作向右的顺序计算。
* 表格的地址：
  * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

# 第五天

## 代码块

* 代码块用来为代码进行分组，在JS中，同一个代码块中的代码要么都执行，要么都不执行。

* 使用{}来创建代码块

* 例子：

* ```javascript
  {
      var a = 10;
      var b = 20;
  	console.log('hello');
  	console.log('你好');
  }
  ```

* 在JS中，使用var声明的变量是没有块作用域的，在代码块内部声明的变量，在其外部也能访问。

* 使用let和const声明的变量具有块作用域。

* let声明的是普通变量，const声明的是常量（只能赋值一次）

## 流程控制语句

* 通过流程控制语句，可以改变代码的执行顺序或者可以使得某段代码反复的执行多次

### 条件判断

* if语句 （❤）

  * 语法：

    * ```javascript
      if(条件表达式){
      	语句...
      }
      ```

    * 执行的流程：

      * if语句执行时，会先对条件表达式进行求值判断，如果结果为true，则执行其后的代码块，结果为false则不执行！

* if-else语句（❤）

  * 语法：

    * ```javascript
      if(条件表达式){
      	语句...
      }else{
      	语句...
      }
      ```

    * 执行流程

      * if-else执行时，会先对if后的条件表达式进行求值判断，如果结果为true，则执行if后的代码块，结果为false，则执行else后的代码块。

* if-else if-else语句（❤）

  * 语法：

    * ```javascript
      if(条件表达式){
      	语句...
      }else if(条件表达式){
      	语句...
      }else if(条件表达式){
      	语句...
      }else{
      	语句...
      }
      ```

    * 执行流程：

      * if-else if-else在执行时，会自上向下依次对条件表达式进行求值判断，如果结果为true，则执行当前if后的代码块，执行完毕语句结束。如果结果为false，则继续向下判断，直到找到true为止。如果所有的条件表达式都是false，则执行else后的语句。
      * 注意：一个if语句中只会有一个代码块代码块被执行。
      * if语句可以嵌套。

### 条件分支（switch语句）

* 语法：

  * ```javascript
    switch(表达式){
    	case 表达式:
    		语句...
    		break;
    	case 表达式:
    		语句...
    		break;
    	case 表达式:
    		语句...
    		break;
    	default:
    		语句...
    		break;
    }
    ```

  * 执行流程：

    * switch-case在执行时，会自上向下依次将case后的表达式和switch后的表达式进行全等比较，如果结果为true，则自当前case处开始向下执行代码，如果结果为false，则继续向下判断，直到找到true为止。如果所有的比较结果都是false，则从default处开始向下执行代码。



### 循环语句

* 循环语句可以用来让某段代码反复执行多次，在js中一共有三种循环语句while、do-while、for。

* while

  * 语法：

    * ```javascript
      while(条件表达式){
      	语句...
      }
      ```

  * 执行流程：

    * while语句执行时，先对while后的条件表达式进行求值判断，如果结果为false，则语句直接结束。如果结果为true，则执行循环体，循环体执行完毕继续对条件表达式进行判断，以此类推。

* do-while

  * 语法：

    * ```javascript
      do{
      	语句...
      }while(条件表达式)
      ```

    * 执行流程:

      * do-while语句执行时，先执行do后的代码块，执行完毕对while后的条件表达式进行求值判断，如果为false则语句结束。如果为true，则继续执行代码块，以此类推。
      * 和while语句相比，do-while可以确保循环体至少可以执行一次，其他情况和while语句没有区别。

* for（❤）

  * 语法：

    * ```javascript
      for(初始化表达式;条件表达式;更新表达式){
      	语句...
      }
      ```

  * 执行流程：

    * for循环执行步骤：
      * 执行初始化表达式，初始化变量（只执行一次）
      * 执行条件表达式判断是否执行循环体
      * 判断结果为true，执行循环体
      * 循环体执行完毕，执行更新表达式
      * 更新表达式执行完毕，重复2

  * 死循环（慎用）

    * ```javascript
      while(true){
      	语句...
      }
      ```

    * ```javascript
      while(1){
      	语句...
      }
      ```

    * ```javascript
      for(;;){
      	语句..
      }
      ```

      

# 第六天

# 第七天

## 对象（object）

* 广义上说，对象就是一种数据结构，所有数据在程序中都可以通过对象来存储。换句话说，所有的东西到了计算机都是对象。（一切皆对象）

* 狭义上说，对象是JS中的一种数据类型（Object）。

* 对象属于一种复合数据类型，在对象可以存储多个不同类型的值，这些值在对象中被称为属性。

* 对象实际上就是一个存储属性的容器。

* 创建对象：

* ```
  var o1 = new Object();
  var o2 = Object();
  var o3 = {}; // 推荐使用这种方式
  ```

* 向对象中添加属性：

* ```
  o1.属性名 = 属性值;
  o2['属性名'] = 属性值;
  ```

* 读取属性：

* ```
  o1.属性名;
  o2['属性名'];
  var a = '属性名';
  o2[a];
  ```

* 属性

  * 属性名：
    * 属性名没有强制的格式要求，可以使用任意字符串作为属性名
    * 但是在实际开发强烈建议属性名要遵循标识符的规范
    * 如果属性名太奇怪了（不符合标识符规范），则必须使用 [] 的形式来设置
  * 属性值：
    * 属性值对象中存储的数据
    * 属性值可以任意的数据类型，可以是对象，也可以是一个函数。

* 对象的字面量：

* ```
  var obj = {属性名:属性值,属性名:属性值,属性名:属性值};
  ```

* 使用typeof检查一个对象时，会返回 "object"

* 可以使用delete关键字，来删除一个对象中的属性

* ```
  delete obj.name;
  ```

* 对象属于可变类型，对象中存储的数据是可以被改变的：

  * “改变量”时，不会影响到其他的变量（给变量重新赋值不会影响其他的变量）：

    例子：

    ```
    var a = 10;
    var b = a;
    a++; //改变量
    a = 11; //改变量
    a += 5; //改变量
    ```

  * ”改对象“时，会影响到所有指向该对象的变量：

    例子：

    ```
    var o1 = {};
    var o2 = {};
    o1.name = 'xxx'; //改对象
    o2.age = 'xxx'; //改对象
    delete o1.name; //改对象
    ```

## 函数（function）

* 函数也是一个对象

* 和其他对象不同，函数可以用来存储代码，并且在需要时对这些代码进行反复的调用

* 函数的创建：

  * 函数声明：

    ```
    function 函数名([形参1, 形参2, ... 形参n]){
    	语句...
    }
    ```

  * 函数表达式

    ```
    var 函数名 = function([形参1, 形参2, ... 形参n]){
    	语句...
    };
    ```

* 函数的调用：

  ```
  函数对象([实参1, 实参2, ... 实参n]);
  ```

* 使用typeof检查一个函数时，会返回 "function"

* 函数的参数：

  * 形参（形式参数）
    * 在定义函数时，可以在函数的()中指定形参
    * 定义形参就相当于在函数中定义了变量但是并没有赋值
    * 形参的实际值最终由实参来决定
  * 实参（实际参数）
    * 在调用函数时，可以在函数的()中指定实参
    * JS不会检查实参的类型和数量，可以传递任意类型的参数
      * 如果实参数量等于形参，则实参形参一一对应
      * 如果实参数量多于形参，对于的不会使用
      * 如果实参数量小于形参，没有实参的形参将会是undefined

* 函数的返回值：

  * 可以通过return来指定函数的返回值

  * 语法：

    ```
    return 值;
    ```

  * 返回值将会作为函数的执行结果返回，可以定义变量来接收返回值。

  * return后可以跟任意的值，如果没有值，则相当于return undefined。

  * return执行后，函数会立即终止，其后的代码都不会执行。

* 立即执行函数（IIFE）

  * 立即执行函数会在定义完成后立即执行，只会执行一次

  * 语法：

    ```
    (function(){
    
    })();
    ```

# 第八天

## 方法（method）

* 一个对象的属性也可以是一个函数，如果对象的属性是函数，则称这个函数是该对象的方法，调用函数就称为调用方法。
* 函数和方法没有本质的区别，函数实际上就是window对象的方法。

## 作用域（scope）

* 作用域指的就是一个变量的作用范围，变量在何处可见！
* 作用域主要分为两种：全局作用域、局部作用域（块作用域、函数作用域）

* 全局作用域：
  * 全局作用域在网页加载时创建，在网页关闭时销毁
  * 所有的<span style='color:red;font-weight:bold;'>直接</span>写在script标签中的变量都在全局作用域中
  * 全局作用域中创建的变量叫做全局变量，函数叫做全局函数
  * 全局函数和变量可以在任意位置被访问
  * 全局作用域中存在一个全局对象window，所有全局变量都会作为window对象的属性保存，所有的全局函数都会作为window对象的方法保存。（不太严谨，只针对var的情况，没有考虑let）
* 函数作用域：
  * 函数作用域在函数调用时创建，调用结束时销毁，每调用一次函数就会创建一个新的函数作用域。
  * 在函数中声明的变量（或参数）都属于局部变量
  * 局部变量对于外部是隐藏的，不能获取（全局作用域无法获取局部作用域的变量）
  * 在函数作用域中，可以访问全局变量
  * 在函数中声明变量时，如果不使用var，变量会成为全局变量
* 变量和函数的提升
  * 使用var声明的变量，使用function开头的函数，会在所有代码执行前执行（在预解析阶段执行）
  * 变量会被提前声明但是不赋值，function会直接创建（所以可以在函数声明前就对其进行调用）
  * 在全局作用域和函数作用域都会出现提升情况
* 作用域链
  * 当访问一个变量时，浏览器会先在当前作用域中寻找该变量，如果找到了则直接使用。如果没有找到则继续向上一层作用域中寻找，以此类推，找到为止。如果一直到全局作用域（window对象）依然没有找到则会报错：xxx is not defined。
  * 搜索变量时，浏览器会沿着作用域链去寻找。

## this

* this是函数中的隐含的参数
* this的值只跟函数的调用方式有关
* 根据调用方式的不同this的值也不同：
  * 以函数形式调用，this是window
    * 例子：
      * xxx()
    * yyy()
  * 以方法形式调用，this是调用方法的对象
    * 例子：
      * xxx.yyy()
      * aaa.bbb()

# 第九天

## 构造函数（constructor）

* 构造函数（类）是专门用来创建对象的函数。

* 构造函数就是一个普通函数，一个函数如果直接调用那么它就是一个普通函数，如果通过new关键字调用那么它就是一个构造函数

* 一个构造函数也称为一个类，通过该构造函数创建的对象，称对象为该类实例。通过同一个构造函数创建的对象，称为一类对象。

  * 普通函数

    ```javascript
    fn(); //普通函数
    ```

  * 构造函数

    ```javascript
    new fn(); //构造函数
    ```

* 构造函数的执行的流程：

  * 构造执行时，会先创建一个新的对象
  * 将新的对象设置为函数中的this
  * 逐行执行函数中的代码
  * 将新的对象作为返回值返回

* this到底是谁？

  * 以函数形式调用函数时，this是window
  * 以方法形式调用函数时，this是调用方法的对象
  * 以构造函数形式调用函数时，this是新创建的对象
  * 未完，待续……

## 原型（prototype）

* JS是一门面向对象的高级语言，它的面向对象是基于原型

* 在函数对象都存在一个属性prototype，该属性指向了一个对象，这个对象就是原型对象。

* 如果函数作为一个普通函数调用这个prototype没有任何作用。

* 如果函数作为一个构造函数调用时，则它所创建的所有实例中都会有一个隐含的属性（\_\_proto\_\_）指向该对象（实例的隐式原型指向构造函数的显示原型）

* 所以原型对象就相当于所有实例的一个公共区域，可以将对象中共有属性（方法）统一设置在原型对象中，这样我们只需设置一次即可让所有的实例都具有这些属性（方法）。

* 创建构造函数（类）时，将独有的属性在函数内部通过this来设置，将共有的属性在函数外部通过原型来设置。

  * 例子：

  * ```
    function MyClass(name,age){
    	this.name = name;
    	this.age = age;
    }
    MyClass.prototype.xxx = xxx;
    MyClass.prototype.yyy = function(){};
    ```

* 原型链：

  * 在访问一个对象的属性时，JS解析器会先在对象本身中寻找，如果找到了，则直接使用。如果没有找到则到对象的原型中寻找，找到了则使用。没有找到则去原型的原型中寻找，以此类推。直到找到Object的原型，它是所有对象原型，如果依然没有找到，则返回undefined。
  * 访问属性时，会沿着对象的原型链搜索，搜索不到不会报错，而是返回undefined。
  * 访问变量时，会沿着作用域链搜索，搜索不到会报错。

* 补充运算符和方法：

  * in 运算符

    * 检查一个对象中是否含有某个属性（原型中含有该属性，也会返回true）

    * ```
      'name' in obj // '属性名' in 对象
      ```

  * instanceof 运算符

    * 检查一个对象是否是某个类的实例（原型链上有该类的实例就会返回true）

    * ```
      obj instanceof Object // 对象 instanceof 构造函数
      ```

  * hasOwnProperty()

    * 检查一个对象自身是否含有某个属性

    * ```
      obj.hasOwnProperty('name') //对象.hasOwnProperty(属性名)
      ```

* toString()

  * 当打印一个对象时，浏览器会自动调用对象的toString()将对象转换为字符串，然后再进行打印。
  * 所以当打印一个对象时，实际上打印的是对象的toString()方法的返回值。
  * 可以通过重写toString()来改变打印对象时的输出的结果。

## 垃圾回收（GC）

* 在编程语言中，不被任何变量或属性引用的对象（不可达对象）被称为垃圾对象。垃圾对象我们无法访问，但依然会占据内存空间。所以必须对垃圾对象进行及时的清理，才能确保程序运行速度不会变慢。
* JS中拥有自动的垃圾回收机制，我们不需要手动回收，只需要将不再使用的变量设置为null即可。
* 垃圾的回收的常见方式：
  * 引用计数
    * 引用计数会带来循环引用的问题，导致一些垃圾不能被正确的回收。
  * 标记清除
    * 标记清除需要遍历所有的对象，所以它的性能会比较差
  * 分代收集
    * 将对象分成两代或三代，一代表示新创建的对象，二代和三代表示老的对象
    * 一代对象检查的频率最高，二代对象次之，三代最少

## 数组（Array）

* 数组也是一个对象，用来存储一组有序的数据

* 数组中存储的数据被称为元素，在数组中通过索引来操作元素

* 索引（index）指的是一组从0开始的整数

* JS中的数组没有大小限制，在数组中可以存储任意类型任意数量的元素

* 存储大量数据时，数组的性能会高于普通的对象

* 数组的使用：

  * 创建数组：

  * ```javascript
    var arr = new Array(); // 通过构造函数创建一个数组
    arr = []; // 通过字面量创建一个数组
    arr = [3,2,1,4,5]; // 创建数组时直接指定数组中的元素
    arr= new Array(3,1,2,3); // 创建数组时直接指定数组中的元素
    arr = new Array(3); // 创建一个指定大小的数组
    ```

  * 向数组中添加元素：

  * ```javascript
    arr[0] = 33; // 向索引为0的位置添加一个元素 语法：数组[索引] = 值;
    ```

  * 删除数组中的元素：

  * ```javascript
    delete arr[0]; // 删除数组中索引为0的元素 语法：delete 数组[索引]
    ```

  * 读取元素：

  * ```javascript
    arr[1]; // 读取索引为1的元素 语法：数组[索引] 读取一个不存在的元素时会返回undefined
    ```

  * 获取数组的长度（元素的个数）：

  * ```javascript
    arr.length // 获取数组的长度（最大索引 + 1）
    ```

  * 修改数组的长度：

  * ```javascript
    arr.length = 3;
    ```

* 数组的遍历：

  * 数组遍历就是将数组中每一个元素都获取出来

  * 方式一：for循环（最传统，最灵活，兼容性也最好）

    * ```javascript
      for(var i=0; i<arr.length; i++){
      	arr[i];
      }
      ```

  * 方式二：for-in遍历

    * ```javascript
      for(var i in arr){
      	arr[i];
      }
      ```

  * 方式三：for-of遍历（老版本浏览器不支持）

    * ```javascript
      for(var e of arr){
      	e;
      }
      ```

* typeof运算符

  * typeof用来检查一个值的类型
    * 检查一个数值时会返回 "number"
    * 检查一个字符串时会返回 "string"
    * 检查一个布尔值时会返回 "boolean"
    * 检查一个undefined时会返回"undefined"
    * 检查一个对象或null时会返回"object"
    * 检查一个函数时会返回"function"
    * 检查一个数组时会返回"object"
    * 其他对象都是返回"object"
    * 检查大整数时，返回"bigint"（了解）
    * 检查Symbol时，返回"symbol"（了解）

# 第十天

## 高阶函数

* 当一个函数的参数或者返回值也是一个函数时，那么这个函数就是一个高阶函数。

  * ```javascript
    function fn(callback){
    	callback();
    }
    
    function fn2(){
        function test(){}
        return test;
    }
    ```

* 把函数作为参数使用：

  * 函数在JS中属于一等对象，别的对象能做的事函数都能做。
  * 所以函数也可以作为参数来使用。
  * 将函数作为参数使用，主要目的是将代码传递到函数中。
  * 作为函数的参数，它由我们定义，但是不由我们调用，这种函数被称为回调函数（callback）。



## 箭头函数

* 箭头函数是函数创建的一种特殊方式

* 语法：

  * ```javascript
    ([参数列表])=>返回值
    ```

* 箭头函数语法简单，主要用于设置回调函数，一般不会使用它来创建普通函数

* 注意事项：

  * ```javascript
    (a, b)=> a + b // 标准语法
    
    a => a + 10 // 如果箭头函数只有一个形参，可以省略()
    
    () => 30 + 10 // 没有形参，()不能省略
    
    () => {   // 如果函数体比较复杂，可以使用代码块{}
        var a = 10;
        var b = 20;
        return a + b;
    }
    
    () => ({a:10, b:33}) // 如果返回值是一个对象字面量，字面量外部必须加()
    ```

* 箭头函数的this，不由它自己的调用方式决定。

* 箭头函数的this，由其外部作用域来决定，外部作用域中的this是啥，箭头函数中的this就是啥！

* this的情况（根据调用方式的不同）：

  * 以函数调用时，this是window
  * 以方法调用时，this是调用方法的对象
  * 以构造函数调用时，this是新对象
  * 箭头函数，this由外层作用域决定
  * 未完

## 数组（array）

* 数组的方法：

  * 类方法（通过构造函数对象来调用的方法）

    * Array.isArray()
      * 用来检查一个值（对象）是否是数组，是数组返回true，不是返回false

  * 实例方法（通过实例对象来调用）

    * push()

      * 向数组的末尾添加一个或多个元素，并返回数组新的长度

    * pop()

      * 删除并返回数组的最后一个元素

    * unshift()

      * 向数组的开头添加一个或多个元素，并返回新的长度

    * shift()

      * 删除并返回数组的第一个元素

    * concat()

      * 用来连接两个或多个数组
      * 该方法不会影响到原数组，而是返回一个新的数组

    * join()

      * 用来将数组中的所有元素拼接为一个字符串
      * 参数：
        * 第一个参数，字符串，该字符串会成为连接符来连接每一个元素
          * 如果不指定，默认使用,作为连接符
      * 不会影响原数组

    * slice()

      * 用来抽取数组中部分元素，生成新数组（不会影响到原来的数组）
      * 参数：
        * 第一个参数，抽取的起始位置索引（包含起始位置）
        * 第二个参数，抽取的结束位置索引（不包含结束位置）
        * 如果省略第二个参数，默认会抽取到最后
        * 索引可以是负值，负值表示倒数第几个

    * splice()

      * 用来删除、添加、替换数组中的元素（会影响到原来的数组）

      * 参数：

        * 第一个参数，删除的起始位置索引
        * 第二个参数，删除的数量
        * 第三个后的参数，要添加的元素

      * 返回值：

        * 返回的是被删除的元素

      * 例子：

        * 删除元素

          * ```javascript
            var result = arr.splice(2,3); // 从索引2开始，向后删除3个元素
            // result 接收到的是被删除的元素
            ```

      * 替换元素

        * ```javascript
          var result = arr.splice(2,3,xxx,yyy,zzz);
          ```

      * 在指定位置插入元素

        * ```javascript
          arr.splice(2, 0, xxx, yyy);javascript
          ```

    * indexOf()

    * lastIndexOf()

      * 用来查询元素在数组中第一次出现的位置
      * 参数：
        * 第一个，被查询的元素
        * 第二个，查询的起始位置（默认 0）
      * 返回值：
        * 找到元素，则返回元素第一次出现的索引
        * 没有找到，则返回-1
      * 区别：
        * indexOf() 从前往后找
        * lastIndexOf() 从后往前找

    * forEach()

      * 为数组中的每一个元素调用函数
      * forEach()需要一个回调函数作为参数，回调函数会调用多次（数组中有几个元素就调用几次），每次调用时，会将元素的信息作为参数传递进回调函数
      * 三个参数：
        * value 当前的元素
        * index 当前元素的索引
        * array 当前被遍历的数组

# 第十一天

## 数组的方法

* every()

  * 用来检查数组中的每一个元素是否都符合要求

  * ```javascript
    var result = arr.every((a)=>a>5);
    ```

* some()

  * 用来检查数组中是否有元素符合要求

  * ```javascript
    var result = arr.some((a)=>a>5);
    ```

* filter()

  * 用来从数组中筛选出符合条件的元素

  * ```javascript
    var result = arr.filter((a)=>a>5);
    ```

* map()

  * 根据原来的数组生成新的数组

  * ```javascript
    var result = arr.map((a)=>a+5);
    ```

* reduce()

  * 对数组中的元素进行汇总

  * ```javascript
    var result = arr.reduce((a,b)=>a+b);
    ```

* reverse()

  * 对数组中的元素进行反转，会影响到原来的数组

* sort()

  * 用来对数组进行排序，默认会按照元素的Unicode编码进行排序

  * 可以通过回调函数来指定排序规则：

    * 升序排列：

      ```javascript
      arr.sort((a,b)=>a-b);
      ```

    * 降序排列

      ```javascript
      arr.sort((a,b)=>b-a);
      ```

## 函数

* arguments

  * 在函数调用时，JS引擎会自动传递进两个隐含的参数this和arguments
  * arguments是一个类数组对象，调用函数时所用的实参都会存储在arguments对象中
  * 通过arguments可以在不定形参情况下，就访问实参
  * arguments[0]表示第一个实参，arguments[1]表示第二个实参 以此类推...
  * arguments.callee()用来表示当前调用的函数对象

* 剩余参数（rest）

  * 在定义形参时，可以使用如下方式定义剩余参数：

    * ```javascript
      function fn(a, b, ...c) {
      
      }
      ```

  * 形参前跟着...则表示参数是剩余参数，剩余参数必须写在参数列表最后，所有的没有形参对应的实参都会保存到剩余参数的数组中。

* call()和apply()

  * 用来调用函数并指定函数的this
  * 不同点：
    * call()的参数需要一个一个的传递
    * apply()的参数需要通过数组（类数组）传递

* this的到底是谁？

  * 根据函数的调用方式不同，函数中的this也不同：
    * 以函数形式调用时，this是window
    * 以方法形式调用时，this是调用方法的对象
    * 以构造函数形式调用时，this是新建的对象
    * 使用call或apply调用时，this是call和apply的第一个参数
    * 全局作用域中的this是window
    * 箭头函数的this由外层作用域决定

* 解构赋值

  * 数组的解构

    * ```javascript
      var [a,b] = [3,4];
      var [c,d,...e] = [1,2,3,4,5,6];
      ```

  * 对象的解构

    * ```javascript
      var [name, age, ...other] = {name:'xxx',age:18,gender:'男',address:'xxxx'};
      ([name, age, ...other] = {name:'xxx',age:18,gender:'男',address:'xxxx'});
      ```

  * 实参的解构

    * ```javascript
      var arr = [1,2,3];
      fn(...arr);
      ```

* 递归

  * 函数自己调用自己的函数就是递归函数
  * 递归的核心思想是将一个大的问题，拆分为一个一个小的问题，然后各个击破
  * 递归的作用和循环是一样的，递归能处理的问题，通过循环也可以解决。循环的执行速度会比较快，递归会比较容易理解。
  * 在实际上开发中，递归也不会大量使用，尤其是对于刚进入公司工作的，尽量避免主动使用递归。
  * 递归的两个条件：
    * 基线条件，递归的停止条件！
    * 递归条件，如何对问题进行拆分！

# 第十二天

## 排序算法

* 冒泡排序（bubble）

  * 原理：反复的比较相邻的两个元素的大小，然后根据需要进行交换位置

  * 性能比较差，不适用元素较多的情况

  * ```javascript
    var arr = [3,4,1,2,6,7,9,0,5,8];
    
    // 排列次数的最大应该为数组的长度-1
    for(var j=0; j<arr.length-1; j++){
        //获取到数组中的每一个元素
        for(var i=0; i<arr.length-1; i++){
        //比较当前元素和后一个元素的大小
        //当前元素 arr[i]  后一个元素arr[i+1]
            if(arr[i] > arr[i+1]){
                // 前边的元素大于后边的元素，交换两个元素的位置
                var temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }
    }
    ```

* 快速排序（quick）

  * 原理：从数组中提取出一个基准值，比基准值大的放到其右侧，比它小的放到其左侧

  * 性能好

  * ```javascript
    var arr = [3,4,1,2,6,7,9,0,5,8];
    
    //创建一个快速排序的函数
    // 对array进行排序，返回一个排好序的新数组
    function quickSort(array) {
        //设置基线条件
        if(array.length <= 1){
        return array;
        }
        // 获取一个基准值，获取数组的最后一个元素作为基准值
        var base = array[array.length-1];
    
        //创建两个数组
        var left = []; //左数组，存储小于base的元素
        var right = []; //右数组，存储大于base的元素
    
        //比较每个元素和base的大小
        for(var i=0; i<array.length - 1; i++){
            // 比较当前值和基准值的大小
            if(array[i] < base){
                //放入到左数组
                left.push(array[i]);
            }else{
                //放入到右数组
                right.push(array[i]);
        	}
    	}
    
        //left base right
        // 将left base right 拼接为一个数组返回
        return quickSort(left).concat(base, quickSort(right));
    }
    
    var result = quickSort(arr);
    ```

## 闭包

* 闭包就是可以访问到外部函数中变量的内部函数

* 闭包的创建：

  * 必须有函数的嵌套
  * 内层函数必须要引用外层函数中的变量
  * 将内层函数作为返回值返回

* 例子：

  * ```javascript
    function outer(){
    	var a = 10;
    	function inner(){
    		console.log(a);
    	}
    	return inner;
    }
    var fn = outer();
    ```

  

* 特点：

  * 闭包在外部函数调用时创建
  * 外部函数每调用一次就产生一个闭包
  * 当内部函数都被垃圾回收闭包即被销毁
  * 应用闭包主要是为了隐藏一些不希望被外部访问的变量

## 对象的复制（拷贝）

* 浅复制
  * 浅复制表示只复制对象的自身，不复制对象的属性
  * 性能比较好
  * 数组的浅复制：
    * slice()
  * 对象的浅复制
    * assign()
* 深复制
  * 深复制不仅会复制对象的自身，同时也会复制对象的属性，甚至是属性的属性
  * 性能差

## 日期对象（Date）

* 在JS中，所有和时间相关信息都由Date对象来表示

* 创建日期对象：

  * 创建一个当前日期对象

  * ```javascript
    var d = new Date();
    ```

  * 创建一个指定的日期对象

  * ```javascript
    var d = new Date('月份/日/年份 时:分:秒');
    ```

* 对象方法：

  * getFullYear()
    * 获取当前日期对象的年份
  * getMonth()
    * 获取当前日期对象的月份
    * 从0开始，0表示1月，1表示2月...
  * getDate()
    * 获取当前日期对象是几日
  * getDay()
    * 获取当前日期对象是周几
    * 从0开始，0表示周日，1表示周一...
  * getTime()
    * 获取当前日期对象的时间戳
    * 时间戳指从1970年1月1日0时0分0秒到现在时刻所经历的毫秒数
    * 在计算机底层所有的时间都是通过时间戳表示的
    * 时间戳会1ms生成一个，重复的几率极低，所以时间戳经常用来生成一些随机的id
  * Date.now()
    * 类方法（静态方法），直接通过函数对象来调用
    * 用来直接获取到当前时间的时间戳

# 第十三天

## Math

* Math是一个用来表示数学运算相关的工具类

* 所谓的工具类就是无需通过它来创建对象，直接可以通过类对象来调用属性和方法

* Math主要包含一些常量和方法，帮助我们来完成数学运算

  * Math.PI

    * 圆周率

  * Math.abs()

    * 获取一个值的绝对值

  * Math.ceil()

    * 对一个数字进行向上取整

  * Math.floor()

    * 对一个数字进行向下取整

  * Math.round()

    * 对一个数字进行四舍五入取整

  * Math.max()

    * 获取多个值中的最大值

  * Math.min()

    * 获取多个值中的最小值

  * Math.pow(x, y)

    * 求x的y次幂

  * Math.sqrt(x)

    * 求一个值的平方根

  * Math.random()

    * 生成一个0-1之间的随机数

    * 生成x-y之间的随机数

      * ```javascript
        Math.round(Math.random()*(y-x)) + x
        ```

## 包装类

* 在JS中为我们提供了三个包装类Number()、String()、Boolean()通过这三个类可以将一个基本数据类型包装为一个对象。
* 当我们对一个基本数据类型调用属性或方法时，JS解析器会临时将基本数据类型包装为对象，然后调用对象的属性或方法，调用完成对象即刻销毁。
* 因为包装类的存在所以我们可以通过数值调用Number的实例方法，通过字符串调用String类型的实例方法，通过布尔值调用Boolean类型的实例方法。

## 字符串

* 字符串其本质就是一个字符数组

  * ```javascript
    var str = 'Hello haha'; 
    // ['H','e','l','l','o',' ','h','a','h','a']
    ```

* 字符串的方法：

  * 注意：所有的字符串的方法都不会影响到原字符串
  * charAt()
    * 根据索引获取指定位置的字符
    * 和 str[index] 类似
  * String.fromCharCode()
    * 根据字符编码返回字符
  * indexOf()
  * lastIndexOf()
    * 在字符串中查找指定的子串，如果找到了则返回其第一次出现的索引，没有找到则返回-1
  * startsWith()
  * endsWith()
    * 判断字符串是否以指定内容开头或结尾
  * slice()
    * 用来截取字符串 
    * 参数：
      * 第一个，截取的起始位置（包含起始位置）
      * 第二个，截取的结束位置（不包含结束位置）
        * 参数可以是负值，负值表示倒数第几个
  * substring()
    * 用来截取字符串 
    * 参数：
      * 第一个，截取的起始位置（包含起始位置）
      * 第二个，截取的结束位置（不包含结束位置）
        * 参数不能是负值，如果是负值自动重置为0，并且如果第一个参数大于第二个参数，它会自动交换位置。
  * split()
    * 拆分字符串，可以将字符串拆分为一个数组
    * 参数：
      * 需要一个字符串作为参数，它会根据该字符串对源字符串进行拆分
      * 如果传递一个空串作为参数，会将字符串中的每一个字符拆分为一个元素
    * 返回值：
      * 返回一个数组，拆分出字符串会成为数组中的元素
    * toLowerCase()
    * 将字符串转换为小写
  * toUpperCase()
    * 将字符串转换为大写
  * trim()
    *  去除字符串两端的空格

## 正则表达式

* 正则表达式用来定义一组字符串的规则，程序可以根据该规则来判断一个字符串是否符合规则，或者从一个字符串中将符合规则的内容提取出来。

* 创建正则的对象

  * ```javascript
    var reg = new RegExp('正则','匹配模式'); 
    ```

  * ```javascript
    var reg = /正则/匹配模式;
    ```

* 正则对象的方法：

  * test()
    * 用来检查一个字符串是否符合正则表达式，符合返回true，不符合返回false

* 正则的基本的语法：

  * | 
    * 表示或的关系
  * [xyz]
    * []中的内容也表示或的关系
    * [a-z] 任意的小写字母
    * [A-Z] 任意的大写字母
    * [0-9] 任意的数字
  * [^]
    * 表示除了
    * [^x] 除了x

# 第十四天

## 正则

* 量词，用来规定字符出现的次数
  * {n}
    * 字符正好出现n次
  * {n,}
    * 字符出现n次以上
  * {n,m}
    * 字符出现n-m次
  * +
    * 字符出现1次以上
  * *
    * 字符出现0到多次
  * ?
    * 字符出现0-1次
  * 注意：使用量词都会有贪婪模式，所谓贪婪模式量词会尽可能多的去匹配内容，可以通过在量词后添加?来关闭贪婪模式。
* 转义字符
  * 在正则中使用\作为转义字符
  * \\. 
    * 表示.
  * .
    * 表示任意字符（除了换行符）
  * \w
    * 任意的单词字符，字母数字下划线(_)
  * \W
    * 除了单词字符
  * \d
    * 任意的数字
  * \D
    * 除了数字
  * \s
    * 空格（空白符）
  * \S
    * 除了空格
  * \b
    * 单词边界（字符串的开头、结尾、空格）
  * \B
    * 除了单词边界
* ^
  * 表示开头
* $
  * 表示结尾
* 字符串中和正则相关方法
  * search()
    * 根据正则表达式在字符串中搜索指定内容
  * split()
    * 根据正则表达式将字符串拆分为一个数组
  * match()
    * 根据正则表达式去字符串中匹配内容
  * replace()
    * 根据正则表达式将字符串中的内容替换为指定内容

## JSON

* JavaScript Object Notation（JS的对象表示法）
* JSON实际就是一个字符串，它的格式和JS对象的格式的类似，JSON字符串可以传递到不同的语言中，并且可以转回为不通语言中的对象，一般通过JSON来完成不同语言之间的通信。
* JSON语法：
  * JSON的格式和JS对象基本一致，但是有两点需要注意：
    * JSON的属性名必须使用双引号
    * 最后一个属性后绝对不能有逗号
  * JSON的类型：
    * JSON对象
      * {}
    * JSON数组
      * []
  * JSON中的可以使用的值：
    * 数值
    * 字符串
    * 布尔值
    * 空值（null）
    * 对象
    * 数组
* JSON工具类
  * JSON.parse()
    * 将一个JSON字符串转换为JS对象
  * JSON.stringify()
    * 将一个JS对象转换为一个JSON字符串

## DOM

* Document Object Model（文档对象模型）

* 通过DOM我们可以使用JS来完成对网页的修改

* 文档

  * 文档表示的整个网页

* 对象

  * DOM将网页中的每一个元素都转换为了对象
  * 转换为对象后，我们就可以以一种完全的面向对象的方式来操作网页

* 模型

  * 模型用来体现对象与对象之间的关系
  * 关系明确了，这样我可以通过任意一个对象找到其他对象

* 节点（Node）

  * 在网页中每一个部分都是一个节点
    * 整个网页是一个节点，html标签是一个节点，h1标签是一个节点，标签中的文字是一个节点，甚至注释也是一个节点。
  * 都是节点，但是类型也不尽相同
    * 文档节点 ❤
      * 代表整个网页
    * 元素节点 ❤
      * 所有的标签都是元素节点
    * 文本节点
      * 标签中的文字就属于文本节点
    * 属性节点
      * 标签中的属性属于属性节点

* 事件（event）

  * 事件指的是用户和网页之间的交互瞬间

  * 处理事件：

    * 可以直接在标签中通过属性来处理事件：

      * ```html
        <button onclick="alert(123)">点我一下</button>
        ```

    * 可以在script标签中通过js来处理事件

      * ```html
        <button id="btn">点我一下</button>
        <script>
        	var btn = document.getElementById('btn');
            // 为btn设置事件的响应函数
            btn.onclick = function(){
              alert(123);  
            };
        </script>
        ```



# 第十五天

## 网页的加载

* 网页的加载顺序是自上向下一行一行加载，一行一行执行

* 如果将JS代码写在页面的最上方，那么它会优先于HTML代码执行，这样将会导致无法正常获取到DOM对象

* 解决方案：

  * 方案一：将JS代码直接编写在body标签的最后

    * ```html
      <body>
      
          <script>
              // JS代码
          </script>
      </body>
      ```

  * 方案二：将JS代码编写在window.onload的回调函数中

    * ```javascript
      window.onload = function(){
      	// JS代码
      };
      ```

## DOM查询

* Document对象的方法

  * 根据元素id属性获取一个元素

    * ```javascript
      document.getElementById()
      ```

  * 根据元素的class属性获取一组元素

    * ```javascript
      document.getElementsByClassName()
      ```

  * 根据元素的标签名获取一组元素

    * ```javascript
      document.getElementsByTagName()
      ```

  * 获取页面中的所有元素

    * ```javascript
      document.getElementsByTagName('*')
      ```

  * 根据选择器字符串获取一个元素

    * ```javascript
      document.querySelector()
      ```

  * 根据选择器字符串获取一组元素

    * ```javascript
      document.querySelectorAll()
      ```

  * 根据元素的name属性获取一组元素

    * ```javascript
      document.getElementsByName()
      ```

  * 获取网页的body元素

    * ```javascript
      document.body
      ```

  * 获取网页中的根元素

    * ```javascript
      document.documentElement
      ```

* Element元素对象的属性和方法

  * 根据标签名获取指定元素的后代元素

    * ```javascript
      ele.getElementsByTagName()
      ```

  * 获取当前元素的所有子节点

    * ```javascript
      ele.childNodes
      ```

  * 获取当前元素的所有子元素

    * ```javascript
      ele.children
      ```

  * 获取当前元素第一个子节点

    * ```javascript
      ele.firstChild
      ```

  * 获取当前元素的最后一个子节点

    * ```javascript
      ele.lastChild
      ```

  * 获取当前元素的第一个/最后一个子元素

    * ```javascript
      ele.firstElementChild
      ele.lastElementChild
      ```

  * 获取当前元素的父节点

    * ```javascript
      ele.parentNode
      ```

  * 获取当前元素前一个/后一个兄弟节点

    * ```javascript
      ele.previousElementSibling
      ele.nextElementSibling
      ```

* 读取对象的属性

  * 语法：对象.属性

    * 例子：

      * ```javascript
        ele.value
        ele.id
        ele.name
        ele.className
        ```

* 设置对象的属性

  * 语法：对象.属性 = 值

    * 例子：

      * ```javascript
        ele.value = 'xx'
        ele.id = 'yy'
        ele.name = 'zz'
        ele.className = 'hh'
        ```

* 读取标签内部的html代码

  * ele.innerHTML 直接返回内部的html代码（带标签）
  * ele.innerText 直接返回内部的文本内容（去标签）
    * 在通过innerText设置文本内容时，它会自动对标签内容进行转义，也就是标签会直接在页面中显示
    * 它会自动的最特殊符号进行转义，以使特殊符号直接显示



# 第十六天

## this到底是谁？

* 根据函数的调用方式不同this的值也不同
  * 以函数形式调用时，this是window
  * 以方法形式调用时，this是调用方法的对象
  * 以构造函数形式调用时，this是新建的对象
  * 使用call和apply调用时，this是call和apply的第一个参数
  * 箭头函数中的this，由外层作用域决定
  * 事件响应函数中的this，是绑定事件的对象

## DOM的增删改

* 根据标签名创建一个元素节点

  * ```javascript
    document.createElement('标签名')
    ```

* 根据文本内容创建一个文本节点（不太常用）

  * ```javascript
    document.createTextNode('文本内容');
    ```

* 向父节点中添加子节点

  * ```javascript
    父节点.appendChild(子节点);
    ```

* 将节点添加到某个节点的前边

  * ```javascript
    父节点.insertBefore(前边, 后边);
    ```

* 使用节点替换已有节点

  * ```javascript
    父节点.replaceChild(新的, 旧的);
    ```

* 删除节点

  * ```javascript
    父节点.removeChild(子节点);
    子节点.parentNode.removeChild(子节点);
    ```

* 也可以通过innerHTML来完成DOM的增删改

# 第十七天

## 样式的操作

* 样式指直接通过JS来操作页面中的CSS样式

* 内联样式：

  * ```javascript
    元素.style.属性名
    ```

  * ```javascript
    元素.style.属性名 = 属性值
    ```

* 读取计算的样式

  * getComputedStyle()
    * 用来获取元素当前的样式
    * 参数：
      * 要读取样式的对象
      * 要读取伪元素
    * 返回值：
      * 返回一个对象，对象中存储了当前元素的所有样式

* 注意：

  * 通过JS读取样式时，如果样式名中带有-，必须对样式名进行修改，将-去掉，-后的字母改大写
    * 例如：background-color  写为  backgroundColor
  * 通过JS读取到的样式都是带有单位，通常不能直接计算
  * getComputedStyle()不支持IE8及以下的浏览器，在IE8以下的浏览器中需要使用currentStyle来获取元素当前的样式

* 其他的样式相关的属性

  * offsetWidth
  * offsetHeight
    * 获取元素的可见框的大小（内容区、内边距和边框）
  * offsetParent
    * 获取元素的定位父元素
    * 距离元素最近的开启了定位的祖先元素，如果所有的祖先元素都没有开启定位则返回body
  * offsetLeft
  * offsetTop
    * 获取元素距离定位父元素的水平和垂直偏移量
  * clientWidth
  * clientHeight
    * 获取元素可见区域的大小（内容区、内边距）
  * scrollWidth
  * scrollHeight
    * 获取元素的滚动区域的大小
  * scrollTop
  * scrollLeft
    * 获取或设置元素垂直和水平滚动条的位置
  * 检查垂直滚动条滚动到底
    * Math.round(scrollHeight - scrollTop) === clientHeight
  * 检查水平滚动条滚动到底
    * Math.round(scrollWidth - scrollLeft) === clientWidth



# 第十八天

## 事件对象（event）

* 事件对象中存储了当前事件相关的详细信息，比如：触发事件的对象、触发事件时鼠标指针的坐标、哪个按键被按下...

* 事件对象由浏览器创建，在事件的响应函数触发时，事件对象会作为实参传递到响应函数中，可以在事件的响应函数中定义形参来接收事件对象。

  * 例子:

  * ```javascript
    box.onclick = function(event){}
    ```

* 注意：IE8及以下的浏览器，事件对象作为window对象的属性保存，需要通过window.event来访问



## 时间的冒泡

* 冒泡就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素上的相同事件也会被触发

* 大多数情况下，对于开发来说冒泡是有利的，比如我们可以利用冒泡来实现事件的委派

* 如果需要取消冒泡，可以通过事件对象来处理：

  * ```javascript
    ev.cancelBubble = true
    ```

  * ```javascript
    ev.stopPropagation()
    ```

* 补充：通过事件对象来取消默认行为：

  * ```javascript
    ev.preventDefault();
    ```

* 事件的委派

  * 当需要为多个元素绑定事件响应函数时，可以将事件绑定到这些元素共有的祖先元素上，这样只需要绑定一次即可为所有的元素都设置上事件。

## 事件对象中的常用属性和方法：

* ev.cancelBubble
  * 用来取消冒泡
* ev.stopPropagation()
  * 用来取消冒泡
* ev.preventDefault()
  * 用来取消默认行为
* ev.target
  * 用来表示触发事件的对象
* ev.currentTarget
  * 用来表示绑定事件的对象，和this类似





# 第十九天

## 事件的绑定

* 事件绑定除了通过元素的属性来绑定事件外，也可以使用addEventListener()来完成事件的绑定
* addEventListener()
  * 参数:
    * 绑定事件的字符串（不要on）
    * 绑定事件的回调函数
    * 事件是否在捕获阶段触发（一般传false）
  * 特点：
    * 可以为一个元素的同一个事件绑定多个响应函数
    * IE8及以下的浏览器不支持该方法
* removeEventListener()
  * 参数：
    * 要删除的事件字符串
    * 要删除的事件响应函数
    * 是否是捕获阶段触发的事件

## 事件的传播

* 事件的传播被分成了三个阶段：
  * 捕获阶段
    * 从最外层元素向触发事件的目标元素进行事件捕获（由外到内）
    * 默认情况下，捕获阶段不会触发事件
  * 目标阶段
    * 事件到达了触发事件的元素
    * 捕获会一直到目标元素结束，冒泡会从目标元素开始
  * 冒泡阶段
    * 从目标元素向外层元素进行事件的冒泡（由内到外）
    * 默认情况下，会在冒泡阶段触发事件

## 鼠标事件

* mousedown
  * 鼠标按下
* mousemove
  * 鼠标移动
* mouseup
  * 鼠标松开
* contextmenu
  * 右键菜单
* wheel
  * 鼠标滚轮
* 事件的地址：
  * https://developer.mozilla.org/en-US/docs/Web/Events

## classList

* classList是元素的一个属性，它是一个类数组对象，元素的class属性值都会存储到该对象中，可以通过该对象来完成各种对class的操作
* contains()
  * 检查列表中是否含有某个类
* add()
  * 向元素中添加一个或多个类
* remove()
  * 移出元素中的一个或多个类
* replace()
  * 替换元素中的一个类
* toggle()
  * 切换元素中的某个类
    * 如果有则删除
    * 如果没有则添加





# 第二十天

## 键盘事件

* keydown
  * 按键按下的事件
* keyup
  * 按键松开的事件
* 注意：
  * 键盘事件只能被可以获取焦点的元素触发，键盘事件通过会绑定给表单项、超链接、document
  * 键盘按下的事件，如果按着一个按键不松开，事件会被持续触发（第一次和第二次触发的间隔会比较长）
* 事件对象的属性：
  * key，显示当前按下的按键信息
  * ctrlKey 判断ctrl是否被按下
  * altKey 判断alt是否被按下
  * shiftKey 判断shift是被按下

## 定时器

* 延时调用

  * 使用setTimeout()来设置延时调用

  * 使用延时调用时，函数不会立即执行，而是在多长时间后被调用

  * 参数：

    * 被调用的函数
    * 间隔的时间（毫秒）

  * 返回值：

    * 返回一个唯一的id作为标识，可以通过该id来关闭延时调用
    * clearTimeout(id)
      * 用来关闭延时调用

  * 例子：

    * ```javascript
      setTimeout(function(){},3000)
      ```

* 定时调用

  * 使用setInterval()来设置函数的定时调用
  * 使用定时调用，函数将会被调用多次，并且每次执行都会间隔一定的时间
  * 它的用法和setTimeout()一样，不同点在于，setTimeout()只会调用一次函数，setInterval()会反复调用多次
  * 需要通过clearInterval()来关闭定时调用



# 第二十一天

## BOM(浏览器对象模型)

* BOM中为我们提供了一组对象，借助这组对象可以通过JS来操作浏览器
  * Window （代表整个浏览器窗口，全局对象）
  * Navigator （表示浏览器的信息）
  * Location （表示浏览器地址栏信息）
  *  History  （表示浏览器的历史记录）
  *  Screen    （表示用户的设备的屏幕信息）
* BOM对象都是window对象的属性，可以通过window对象访问，也可以直接访问
                      window.navigator
* location 表示的是浏览器的地址栏信息
  * 可以通过window.location 或 location来对其进行访问
  * location用于获取或设置浏览器的地址栏
  * 如果直接打印location可以获取到浏览器的地址栏信息
  * 也可以对其进行修改，修改后浏览器将会跳转到修改后的地址
  * 通过修改location跳转地址会产生历史记录
*  assign()
  * 用来修改location的值，和直接修改location效果一样
*   replace()
  * 使用新的页面替换当前页面，不会生成历史记录
*    reload()
  * 刷新当前页面，相当于刷新按钮
*  reload(true)
  * 强制清缓存刷新页面
* ​    History
  *  表示浏览器的历史记录
  * 可以通过window.history 或 history来对其进行访问
  * 历史记录这种东西属于个人隐私，所以JS无法直接访问用户的历史记录
                        它只能用来控制浏览器向前向后翻页
*  history.forward()
  * 用来切换到下一页，就相当于浏览器的向前按钮
*   history.back()
  * 用来回退到上一页，相当于浏览器的回退按钮
*  history.go();
  * 用来跳转到只能的记录
  *  需要一个整数作为参数：
  *   1 前进1页
  *   2 前进2页
  *  -1 回退1页
  * -2 回退2页
* Navigator
  * 该对象表示的是浏览器的信息
  * 可以通过 window.navigator 或 navigator来对其进行访问
  * 可以通过navigator来识别浏览器的信息
  * 由于历史原因Navigator中的大部分属性都不能用来识别浏览器
  * 只剩下一个还有点用的属性 userAgent
    *  userAgent 是一个字符串，字符串中包含浏览器的描述信息
  * 火狐的：
    * Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0
  *  Chrome
    * Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4168.2 Safari/537.36
  * IE
    * Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko
  * 















​	











































































































